extern. get_insert_block ‡(: Int)
extern. set_insert_block ‡(Int : #())
extern. create_block ‡(: Int)
extern. begin_new_function ‡(Int : Int)
extern. codegen_rc_incr ‡(Int : #())
extern. codegen_rc_decr ‡(Int : #())
extern. codegen_const_bool ‡(Int : Int)
extern. codegen_const_int ‡(Int : Int)
extern. codegen_tuple ‡(Int : Int)
extern. codegen_list ‡(Int : Int)
extern. codegen_cell_rc_incr ‡(Int : #())
extern. codegen_cell_rc_decr ‡(Int : #())
extern. codegen_create_mut_var ‡(Int : Int)
extern. codegen_load_mut_var ‡(Int : Int)
extern. codegen_store_mut_var ‡(Int Int : #())
extern. codegen_unreachable ‡(: #())
extern. codegen_br ‡(Int : #())
extern. codegen_cond_br ‡(Int Int Int : #())
extern. codegen_phi ‡(Int : Int)
extern. phi_add_incoming ‡(Int Int Int : #())
extern. codegen_apply ‡(Int Int : Int)
extern. codegen_get_arg ‡(Int : Int)
extern. get_captures_type ‡(Int Int : Int)
extern. codegen_get_captures ‡(: Int)
extern. codegen_pointer_bitcast ‡(Int Int : Int)
extern. codegen_extract_capture ‡(Int Int : Int)
extern. codegen_ret ‡(Int : #())
extern. codegen_func_val ‡(Int Int Int : Int)
extern. codegen_create_tagless_ctor ‡(Int : Int)
extern. codegen_create_tagged_ctor ‡(Int Int : Int)
extern. bind_pattern_end ‡(Int Int : #())
extern. codegen_int_pattern_test ‡(Int Int : Int)
extern. codegen_tuple_cast ‡(Int Int : Int)
extern. codegen_tagged_cast ‡(Int Int : Int)
extern. codegen_tag_check ‡(Int Int : Int)
extern. codegen_tuple_get ‡(Int Int : Int)
extern. codegen_list_cast ‡(Int : Int)
extern. codegen_len_check ‡(Int Int : Int)
extern. codegen_list_get ‡(Int Int : Int)
extern. codegen_extern ‡(Int Int Int : Int)
extern. codegen_arith_primitive ‡(Int : Int)
extern. codegen_div_primitive ‡(Int : Int)
extern. codegen_cmp_primitive ‡(Int : Int)
extern. codegen_len_primitive ‡(: Int)
extern. codegen_get_primitive ‡(: Int)
extern. codegen_put_primitive ‡(: Int)
extern. codegen_push_primitive ‡(: Int)
extern. codegen_pop_primitive ‡(: Int)

let. begin_new_block λ.{}
    let. bb create_block()
    set_insert_block(bb)
    bb

type. C_Variable
    C_ConstVar(Int)
    C_MutVar(Int)
    C_Ctor(Int Option(Int))
    C_Unused()
    C_DCtor(Option(Int))

let. codegen_var_rc_decr λ.{var 'C_Variable}
    match. var
    .C_ConstVar(val) codegen_rc_decr(val)
    .C_MutVar(var) codegen_cell_rc_decr(var)
    .C_Ctor(val _) codegen_rc_decr(val)
    .C_Unused() #()
    .C_DCtor(_) #()

let. codegen_var_rc_incr λ.{var 'C_Variable}
    match. var
    .C_ConstVar(val) codegen_rc_incr(val)
    .C_MutVar(var) codegen_cell_rc_incr(var)
    .C_Ctor(val _) codegen_rc_incr(val)
    .C_Unused() #()
    .C_DCtor(_) #()

type. C_Context C_Context(
    List(#(List(Int) C_Variable))         ※ vars
    List(#(List(Int) List(List(T_Type)))) ※ types
)

let. c_add_let_binding λ.{context 'C_Context name 'List(Int) var 'C_Variable}
    let. C_Context(vars types) context
    C_Context(push[#(List(Int) C_Variable)](vars #(name var)) types)

let. c_add_type_binding λ.{context 'C_Context type_params 'List(Int) variants 'List(List(T_Type))}
    let. C_Context(vars types) context
    C_Context(vars push[#(List(Int) List(List(T_Type)))](types #(type_params variants)))

let. c_lookup_var λ.{name 'List(Int) context 'C_Context}
    let. mut, r None[C_Variable]()
    let. C_Context(vars _) context
    for[#(List(Int) C_Variable)](vars λ.(var '#(List(Int) C_Variable)
        let. #(name′ val) var
        if. =list[Int](name′ name =)
        then, set. r Some[C_Variable](val)
        else, #()
    ))
    match. r
    .Some(val) val
    .None()
        unreachable("Variable not found in context")
        C_ConstVar(0)

let. extern_binding λ.{name 'List(Int) num_params 'Int ret_int 'Int}
    #(name C_ConstVar(codegen_extern(list→vector(name) num_params ret_int)))

let. get_empty_c_context λ.{}
    C_Context(
        list.(
        #("⊤" C_ConstVar(codegen_const_bool(1)))
        #("⊥" C_ConstVar(codegen_const_bool(0)))
        #("+" C_ConstVar(codegen_arith_primitive(0)))
        #("-" C_ConstVar(codegen_arith_primitive(1)))
        #("*" C_ConstVar(codegen_arith_primitive(2)))
        #("/" C_ConstVar(codegen_div_primitive(0)))
        #("%" C_ConstVar(codegen_div_primitive(1)))
        #("=" C_ConstVar(codegen_cmp_primitive(0)))
        #("≠" C_ConstVar(codegen_cmp_primitive(1)))
        #("<" C_ConstVar(codegen_cmp_primitive(2)))
        #("≤" C_ConstVar(codegen_cmp_primitive(3)))
        #(">" C_ConstVar(codegen_cmp_primitive(4)))
        #("≥" C_ConstVar(codegen_cmp_primitive(5)))
        #("empty" C_ConstVar(codegen_list(list→vector(empty[Int]))))
        #("len" C_ConstVar(codegen_len_primitive()))
        #("get" C_ConstVar(codegen_get_primitive()))
        #("put" C_ConstVar(codegen_put_primitive()))
        #("push" C_ConstVar(codegen_push_primitive()))
        #("pop" C_ConstVar(codegen_pop_primitive()))
        extern_binding("print_int" 1 0)
        extern_binding("read_int" 0 1)
        extern_binding("print_byte" 1 0)
        extern_binding("read_byte" 0 1)
        extern_binding("get_argc" 0 1)
        extern_binding("get_argv_len" 1 1)
        extern_binding("get_argv_byte" 2 1)
        )
        list.(#(empty[Int] list.(empty[T_Type])) #(empty[Int] list.(empty[T_Type])) #(list.(3) list.(empty[T_Type])))
    )

let. mut, c_substitute_in_type λ.{type 'T_Type subs 'List(#(Int T_Type))} type
set. c_substitute_in_type λ.{type 'T_Type subs 'List(#(Int T_Type))}
    match. type
    .T_Named(tn type_args)
        let. mut, t′ None[T_Type]()
        for[#(Int T_Type)](subs λ.(sub '#(Int T_Type)
            let. #(stn st) sub
            if. =(stn tn)
            then, set. t′ Some[T_Type](st)
            else, #()
        ))
        match. t′
        .Some(t′) t′
        .None() T_Named(tn map[T_Type T_Type](type_args λ.(t 'T_Type c_substitute_in_type(t subs))))
    .T_TupleType(subtypes) T_TupleType(map[T_Type T_Type](subtypes λ.(t 'T_Type c_substitute_in_type(t subs))))
    .T_Function(params ret) T_Function(map[T_Type T_Type](params λ.(t 'T_Type c_substitute_in_type(t subs))) c_substitute_in_type(ret subs))

let. mut, is_match_exhaustive λ.{pattern_lists 'List(List(T_Pattern)) types 'List(T_Type) context 'C_Context} ⊥
set. is_match_exhaustive λ.{pattern_lists 'List(List(T_Pattern)) types 'List(T_Type) context 'C_Context}
    if. =(len[T_Type](types) 0)
    then, ≠(len[List(T_Pattern)](pattern_lists) 0)
    else,
        let. pattern_lists′ map_opt[List(T_Pattern) List(T_Pattern)](pattern_lists λ.(ps 'List(T_Pattern)
            let. T_Pattern(pd _ _) get[T_Pattern](ps 0)
            match. pd
            .T_IdentPattern(_) Some[List(T_Pattern)](drop[T_Pattern](ps 1))
            .T_WildcardPattern() Some[List(T_Pattern)](drop[T_Pattern](ps 1))
            ._ None[List(T_Pattern)]()
        ))
        if. ≠(len[List(T_Pattern)](pattern_lists′) 0)
        then, is_match_exhaustive(pattern_lists′ drop[T_Type](types 1) context)
        else, match. get[T_Type](types 0)
            .T_Named(ti type_args)
                let. C_Context(_ ctx_types) context
                let. #(type_params variants) get[#(List(Int) List(List(T_Type)))](ctx_types ti)
                let. subs match. zip[Int T_Type](type_params type_args)
                    .Some(subs) subs
                    .None()
                        unreachable("type_args and type_params are not equal length")
                        empty[#(Int T_Type)]
                let. variants map[List(T_Type) List(T_Type)](variants λ.(variant 'List(T_Type)
                    map[T_Type T_Type](variant λ.(t 'T_Type c_substitute_in_type(t subs)))
                ))
                ∀[#(Int List(T_Type))](ι*[List(T_Type)](variants) λ.(vs '#(Int List(T_Type))
                    let. #(vi subtypes) vs
                    let. pattern_lists′ map_opt[List(T_Pattern) List(T_Pattern)](pattern_lists λ.(ps 'List(T_Pattern)
                        match. get[T_Pattern](ps 0)
                        .T_Pattern(T_VariantPattern(name subpatterns _) _ file_pos) match. c_lookup_var(name context)
                            .C_Ctor(_ vi′) if. =(default[Int](0 vi′) vi)
                                then, Some[List(T_Pattern)](++[T_Pattern](subpatterns drop[T_Pattern](ps 1)))
                                else, None[List(T_Pattern)]()
                            .C_DCtor(vi′) if. =(default[Int](0 vi′) vi)
                                then, Some[List(T_Pattern)](++[T_Pattern](subpatterns drop[T_Pattern](ps 1)))
                                else, None[List(T_Pattern)]()
                            ._
                                error(NotACtor(name) file_pos)
                                None[List(T_Pattern)]()
                        ._ None[List(T_Pattern)]()
                    ))
                    if. ≠(len[List(T_Pattern)](pattern_lists′) 0)
                    then, is_match_exhaustive(pattern_lists′ ++[T_Type](subtypes drop[T_Type](types 1)) context)
                    else, ⊥
                ))
            .T_TupleType(subtypes)
                let. pattern_lists′ map_opt[List(T_Pattern) List(T_Pattern)](pattern_lists λ.(ps 'List(T_Pattern)
                    match. get[T_Pattern](ps 0)
                    .T_Pattern(T_TuplePattern(subpatterns) _ _)
                        Some[List(T_Pattern)](++[T_Pattern](subpatterns drop[T_Pattern](ps 1)))
                    ._ None[List(T_Pattern)]()
                ))
                if. ≠(len[List(T_Pattern)](pattern_lists′) 0)
                then, is_match_exhaustive(pattern_lists′ ++[T_Type](subtypes drop[T_Type](types 1)) context)
                else, ⊥
            .T_Function(_ _) ⊥

let. mut, pattern_vars λ.{pattern 'T_Pattern} empty[List(Int)]
set. pattern_vars λ.{pattern 'T_Pattern}
    let. rec λ. subpatterns 'List(T_Pattern) dedup[List(Int)](concat[List(Int)](map[T_Pattern List(List(Int))](subpatterns pattern_vars)) =list_int)
    let. T_Pattern(pattern_data _ _) pattern
    match. pattern_data
    .T_IntLiteralPattern(_) empty[List(Int)]
    .T_IdentPattern(name) list.(name)
    .T_WildcardPattern() empty[List(Int)]
    .T_TuplePattern(subpatterns) rec(subpatterns)
    .T_VariantPattern(_ subpatterns _) rec(subpatterns)
    .T_ListPattern(subpatterns) rec(subpatterns)

let. mut, free_vars λ.{expr 'T_Expr} empty[List(Int)]
set. free_vars λ.{expr 'T_Expr}
    let. rec λ. subexprs 'List(T_Expr) dedup[List(Int)](concat[List(Int)](map[T_Expr List(List(Int))](subexprs free_vars)) =list_int)
    let. T_Expr(expr_data _ _) expr
    match. expr_data
    .T_IntLiteral(_) empty[List(Int)]
    .T_Ident(name _) list.(name)
    .T_Tuple(subexprs) rec(subexprs)
    .T_Apply(func args) rec(push[T_Expr](args func))
    .T_Set(name subexpr) push[List(Int)](free_vars(subexpr) name)
    .T_If(cond then else) rec(list.(cond then else))
    .T_While(cond body) rec(list.(cond body))
    .T_Do(statements)
        let. mut, bound_vars empty[List(Int)]
        let. mut, do_free_vars empty[List(Int)]
        for[T_Statement](statements λ.(statement 'T_Statement
            match. statement
            .T_ExprStatement(expr) set. do_free_vars ++[List(Int)](do_free_vars \[List(Int)](free_vars(expr) bound_vars =list_int))
            .T_Let(pattern expr)
                set. do_free_vars ++[List(Int)](do_free_vars \[List(Int)](free_vars(expr) bound_vars =list_int))
                set. bound_vars ++[List(Int)](bound_vars pattern_vars(pattern))
            .T_Let∀(_ name expr)
                set. do_free_vars ++[List(Int)](do_free_vars \[List(Int)](free_vars(expr) bound_vars =list_int))
                set. bound_vars push[List(Int)](bound_vars name)
            .T_LetMut(name expr)
                set. do_free_vars ++[List(Int)](do_free_vars \[List(Int)](free_vars(expr) bound_vars =list_int))
                set. bound_vars push[List(Int)](bound_vars name)
            .T_TypeStatement(_ _) #()
            .T_Extern(name _)
                set. bound_vars push[List(Int)](bound_vars name)
        ))
        dedup[List(Int)](do_free_vars =list_int)
    .T_Lambda(params body) \[List(Int)](free_vars(body) concat[List(Int)](map[T_Pattern List(List(Int))](params pattern_vars)) =list_int)
    .T_Cond(cases) rec(concat[T_Expr](map[#(T_Expr T_Expr) List(T_Expr)](cases λ.(case '#(T_Expr T_Expr)
        let. #(cond body) case
        list.(cond body)
    ))))
    .T_Match(subexpr cases) dedup[List(Int)](concat[List(Int)](push[List(List(Int))](map[#(T_Pattern T_Expr) List(List(Int))](cases λ.(case '#(T_Pattern T_Expr)
        let. #(pattern body) case
        \[List(Int)](free_vars(body) pattern_vars(pattern) =list_int)
    )) free_vars(subexpr))) =list_int)
    .T_ListLiteral(subexprs) rec(subexprs)

let. mut, codegen_expr λ.{expr 'T_Expr context 'C_Context} 0
let. mut, codegen_statements λ.{statements 'List(T_Statement) context 'C_Context} 0
let. mut, codegen_pattern_test λ.{val 'Int pattern 'T_Pattern context 'C_Context} #(empty[#(List(Int) C_Variable)] empty[Int])

set. codegen_expr λ.{expr 'T_Expr context 'C_Context}
    let. T_Expr(expr_data expr_type file_pos) expr
    match. expr_data
    .T_IntLiteral(n) codegen_const_int(n)
    .T_Ident(name _)
        let. val match. c_lookup_var(name context)
            .C_ConstVar(val) val
            .C_MutVar(var) codegen_load_mut_var(var)
            .C_Ctor(ctor _) ctor
            .C_Unused()
                unreachable("Variable incorrectly marked as unused")
                0
            .C_DCtor(_)
                unreachable("Variable incorrectly marked as unused")
                0
        codegen_rc_incr(val)
        val
    .T_Tuple(exprs)
        codegen_tuple(list→vector(map[T_Expr Int](exprs λ.(e 'T_Expr codegen_expr(e context)))))
    .T_Apply(func args)
        codegen_apply(codegen_expr(func context) list→vector(map[T_Expr Int](args λ.(e 'T_Expr codegen_expr(e context)))))
    .T_Set(name expr)
        match. c_lookup_var(name context)
        .C_MutVar(var)
            let. val codegen_expr(expr context)
            codegen_rc_decr(codegen_load_mut_var(var))
            codegen_store_mut_var(var val)
        .C_Unused()
            unreachable("Variable incorrectly marked as unused")
        ._ error(AssignToConst(name) file_pos)
        codegen_tuple(list→vector(empty[Int]))
    .T_If(cond then else)
        let. cond_val codegen_expr(cond context)
        let. cond_val_block get_insert_block()
        let. then_block begin_new_block()
        let. then_val codegen_expr(then context)
        let. then_val_block get_insert_block()
        let. else_block begin_new_block()
        let. else_val codegen_expr(else context)
        let. else_val_block get_insert_block()
        let. merge_block begin_new_block()
        set_insert_block(cond_val_block)
        codegen_cond_br(cond_val then_block else_block)
        set_insert_block(then_val_block)
        codegen_br(merge_block)
        set_insert_block(else_val_block)
        codegen_br(merge_block)
        set_insert_block(merge_block)
        let. phi codegen_phi(2)
        phi_add_incoming(phi then_val then_val_block)
        phi_add_incoming(phi else_val else_val_block)
        phi
    .T_While(cond body)
        let. cond_block create_block()
        codegen_br(cond_block)
        set_insert_block(cond_block)
        let. cond_val codegen_expr(cond context)
        let. cond_val_block get_insert_block()
        let. body_block begin_new_block()
        codegen_rc_decr(codegen_expr(body context))
        codegen_br(cond_block)
        let. merge_block create_block()
        set_insert_block(cond_val_block)
        codegen_cond_br(cond_val body_block merge_block)
        set_insert_block(merge_block)
        codegen_tuple(list→vector(empty[Int]))
    .T_Do(statements) codegen_statements(statements context)
    .T_Lambda(params body)
        let. parent_block get_insert_block()
        let. C_Context(vars types) context
        let. body_free_vars free_vars(body)
        let. mut, is_captured empty[Bool]
        for[#(List(Int) C_Variable)](vars λ.(var '#(List(Int) C_Variable) set.(is_captured push[Bool](is_captured ⊥))))
        for[List(Int)](body_free_vars λ.(name 'List(Int)
            let. mut, cap_var_i None[Int]()
            for_ι(len[#(List(Int) C_Variable)](vars) λ.(i 'Int
                let. #(name′ _) get[#(List(Int) C_Variable)](vars i)
                if. =list[Int](name′ name =)
                    set. cap_var_i Some[Int](i)
                else, #()
            ))
            match. cap_var_i
            .Some(cap_var_i)
                set. is_captured put[Bool](is_captured cap_var_i ⊤)
            .None() #()
        ))
        let. outer_captures list→vector(map_opt[#(Int #(List(Int) C_Variable)) Int](ι*[#(List(Int) C_Variable)](vars) λ.(i_var '#(Int #(List(Int) C_Variable))
            let. #(i #(name var)) i_var
            if. get[Bool](is_captured i)
                let. cap match. var
                    .C_ConstVar(val)
                        codegen_rc_incr(val)
                        val
                    .C_MutVar(ptr)
                        codegen_cell_rc_incr(ptr)
                        ptr
                    .C_Ctor(ctor _)
                        codegen_rc_incr(ctor)
                        ctor
                    .C_Unused()
                        unreachable("Variable incorrectly marked as unused")
                        0
                    .C_DCtor(_)
                        unreachable("Variable incorrectly marked as unused")
                        0
                Some[Int](cap)
            else, None[Int]()
        )))
        let. captures_type get_captures_type(len[T_Pattern](params) outer_captures)
        let. func begin_new_function(len[T_Pattern](params))
        let. inner_captures_box codegen_get_captures()
        let. inner_captures codegen_pointer_bitcast(inner_captures_box captures_type)
        let. mut, cap_struct_i 0
        let. vars′ ++[#(List(Int) C_Variable)](
            map[#(Int #(List(Int) C_Variable)) #(List(Int) C_Variable)](ι*[#(List(Int) C_Variable)](vars) λ.(i_var '#(Int #(List(Int) C_Variable))
                let. #(i #(name var)) i_var
                if. get[Bool](is_captured i)
                    let. cap codegen_extract_capture(inner_captures cap_struct_i)
                    set. cap_struct_i +(cap_struct_i 1)
                    let. var′ match. var
                        .C_ConstVar(_) C_ConstVar(cap)
                        .C_MutVar(_) C_MutVar(cap)
                        .C_Ctor(_ tag) C_Ctor(cap tag)
                        .C_Unused()
                            unreachable("Variable incorrectly marked as unused")
                            C_Unused()
                        .C_DCtor(tag) C_DCtor(tag)
                    codegen_var_rc_incr(var′)
                    #(name var′)
                else,
                    let. var′ match. var
                        .C_Ctor(_ tag) C_DCtor(tag)
                        .C_DCtor(tag) C_DCtor(tag)
                        ._ C_Unused()
                    #(name var′)
            ))
            concat[#(List(Int) C_Variable)](map_ι[List(#(List(Int) C_Variable))](len[T_Pattern](params) λ.(i 'Int
                let. arg codegen_get_arg(i)
                let. #(bindings pattern_ends) codegen_pattern_test(arg get[T_Pattern](params i) context)
                if. ≠(len[Int](pattern_ends) 0)
                    unreachable("pattern_ends not empty")
                else, #()
                for[#(List(Int) C_Variable)](bindings λ.(binding '#(List(Int) C_Variable)
                    let. #(_ var) binding
                    codegen_var_rc_incr(var)
                ))
                codegen_rc_decr(arg)
                bindings
            )))
        )
        let. context′ C_Context(vars′ types)
        codegen_rc_decr(inner_captures_box)
        let. ret_val codegen_expr(body context′)
        for[#(List(Int) C_Variable)](vars′ λ.(binding '#(List(Int) C_Variable)
            let. #(_ var) binding
            codegen_var_rc_decr(var)
        ))
        codegen_ret(ret_val)
        set_insert_block(parent_block)
        codegen_func_val(func outer_captures captures_type)
    .T_Cond(cases)
        let. C_Context(vars _) context
        if. ¬(∧(
            =(count[#(List(Int) C_Variable)](vars λ.(var '#(List(Int) C_Variable)
                let. #(name _) var
                =list[Int](name "⊤" =)
            )) 1)
            ∃[#(T_Expr T_Expr)](cases λ.(case '#(T_Expr T_Expr)
                match. case
                .#(T_Expr(T_Ident("⊤" _) _ _) _) ⊤
                ._ ⊥
            ))
        ))
        then, error(InvalidExpr(Some[List(Int)]("cond")) file_pos)
        else, #()
        let. branches map[#(T_Expr T_Expr) #(Int Int)](cases λ.(case '#(T_Expr T_Expr)
            let. #(cond body) case
            let. cond_val codegen_expr(cond context)
            let. cond_val_block get_insert_block()
            let. body_block begin_new_block()
            let. body_val codegen_expr(body context)
            let. body_end get_insert_block()
            let. next_block create_block()
            set_insert_block(cond_val_block)
            codegen_cond_br(cond_val body_block next_block)
            set_insert_block(next_block)
            #(body_val body_end)
        ))
        codegen_unreachable()
        let. merge_block begin_new_block()
        let. phi codegen_phi(len[#(Int Int)](branches))
        for[#(Int Int)](branches λ.(branch '#(Int Int)
            let. #(body_val body_end) branch
            set_insert_block(body_end)
            codegen_br(merge_block)
            phi_add_incoming(phi body_val body_end)
        ))
        set_insert_block(merge_block)
        phi
    .T_Match(expr cases)
        let. T_Expr(_ expr_type expr_file_pos) expr
        if. ¬(is_match_exhaustive(map[#(T_Pattern T_Expr) List(T_Pattern)](cases λ.(case '#(T_Pattern T_Expr)
            let. #(pattern _) case
            list.(pattern)
        )) list.(expr_type) context))
        then, error(InexhaustivePatterns() expr_file_pos)
        else, #()
        let. C_Context(old_context_vars _) context
        let. old_context_len len[#(List(Int) C_Variable)](old_context_vars)
        let. matched_val codegen_expr(expr context)
        let. branches map[#(T_Pattern T_Expr) #(Int Int)](cases λ.(case '#(T_Pattern T_Expr)
            let. #(pattern body) case
            let. #(bindings pattern_ends) codegen_pattern_test(matched_val pattern context)
            let. mut, context′ context
            for[#(List(Int) C_Variable)](bindings λ.(bind '#(List(Int) C_Variable)
                let. #(name var) bind
                codegen_var_rc_incr(var)
                set. context′ c_add_let_binding(context′ name var)
            ))
            codegen_rc_decr(matched_val)
            let. body_val codegen_expr(body context′)
            let. C_Context(context_vars _) context
            for_ι(-(len[#(List(Int) C_Variable)](context_vars) old_context_len) λ.(i 'Int
                let. #(_ var) get[#(List(Int) C_Variable)](context_vars +(i old_context_len))
                codegen_var_rc_decr(var)
            ))
            let. body_end get_insert_block()
            let. next_block create_block()
            for[Int](pattern_ends λ.(pattern_end 'Int
                bind_pattern_end(pattern_end next_block)
            ))
            set_insert_block(next_block)
            #(body_val body_end)
        ))
        codegen_unreachable()
        let. merge_block begin_new_block()
        let. phi codegen_phi(len[#(Int Int)](branches))
        for[#(Int Int)](branches λ.(branch '#(Int Int)
            let. #(body_val body_end) branch
            set_insert_block(body_end)
            codegen_br(merge_block)
            phi_add_incoming(phi body_val body_end)
        ))
        set_insert_block(merge_block)
        phi
    .T_ListLiteral(exprs)
        codegen_list(list→vector(map[T_Expr Int](exprs λ.(e 'T_Expr codegen_expr(e context)))))

set. codegen_statements λ.{statements 'List(T_Statement) context 'C_Context}
    let. mut, context context
    let. C_Context(old_context_vars old_context_types) context
    let. old_context_len len[#(List(Int) C_Variable)](old_context_vars)
    let. mut, type_index_base len[#(List(Int) List(List(T_Type)))](old_context_types)
    for[T_Statement](statements λ.(statement 'T_Statement
        match. statement
        .T_TypeStatement(num_type_params variants) set. type_index_base +(type_index_base 1)
        ._ #()
    ))
    for[T_Statement](statements λ.(statement 'T_Statement
        match. statement
        .T_TypeStatement(num_type_params variants) set. context c_add_type_binding(context
            map_ι[Int](num_type_params λ.(i 'Int +(type_index_base i)))
            map[#(List(Int) List(T_Type)) List(T_Type)](variants λ.(v '#(List(Int) List(T_Type))
                let. #(_ v) v
                v
            ))
        )
        ._ #()
    ))
    let. mut, block_val None[Int]()
    for[T_Statement](statements λ.(statement 'T_Statement
        match. statement
        .T_ExprStatement(expr)
            match. block_val
            .Some(val) codegen_rc_decr(val)
            .None() #()
            set. block_val Some[Int](codegen_expr(expr context))
        .T_Let(pattern expr)
            let. T_Expr(_ expr_type expr_file_pos) expr
            if. ¬(is_match_exhaustive(list.(list.(pattern)) list.(expr_type) context))
            then, error(InexhaustivePatterns() expr_file_pos)
            else, #()
            let. val codegen_expr(expr context)
            let. #(bindings pattern_ends) codegen_pattern_test(val pattern context)
            if. ≠(len[Int](pattern_ends) 0)
                unreachable("pattern_ends not empty")
            else, #()
            for[#(List(Int) C_Variable)](bindings λ.(bind '#(List(Int) C_Variable)
                let. #(name var) bind
                codegen_var_rc_incr(var)
                set. context c_add_let_binding(context name var)
            ))
            codegen_rc_decr(val)
        .T_Let∀(type_params name expr)
            let. mut, context′ context
            for_ι(type_params λ.(i 'Int set.(context′ c_add_type_binding(context′ empty[Int] list.(empty[T_Type])))))
            set. context c_add_let_binding(context name C_ConstVar(codegen_expr(expr context)))
        .T_LetMut(name expr)
            set. context c_add_let_binding(context name C_MutVar(codegen_create_mut_var(codegen_expr(expr context))))
        .T_TypeStatement(num_params variants)
            if. =(len[#(List(Int) List(T_Type))](variants) 1)
                let. #(name params) get[#(List(Int) List(T_Type))](variants 0)
                set. context c_add_let_binding(context name C_Ctor(codegen_create_tagless_ctor(len[T_Type](params)) None[Int]()))
            else,
                for_ι(len[#(List(Int) List(T_Type))](variants) λ.(i 'Int
                    let. #(name params) get[#(List(Int) List(T_Type))](variants i)
                    set. context c_add_let_binding(context name C_Ctor(codegen_create_tagged_ctor(len[T_Type](params) i) Some[Int](i)))
                ))
        .T_Extern(name type)
            let. file_pos FilePos("[extern.]" 0 0)
            match. type
            .T_Function(params ret)
                let. TypeName(int_type_index) int_type
                for[T_Type](params λ.(param 'T_Type
                    match. param
                    .T_Named(i _)
                        if. ≠(i int_type_index)
                            error(InvalidExternType(name) file_pos)
                        else, #()
                    ._
                        error(InvalidExternType(name) file_pos)
                ))
                let. ret_int match. ret
                    .T_Named(i _)
                        if. ≠(i int_type_index)
                            error(InvalidExternType(name) file_pos)
                        else, #()
                        ⊤
                    .T_TupleType(list.()) ⊥
                    ._
                        error(InvalidExternType(name) file_pos)
                        ⊥
                set. context c_add_let_binding(context name C_ConstVar(codegen_extern(utf8_encode(list→vector(name)) len[T_Type](params) if.(ret_int 1 0))))
            ._
                error(InvalidExternType(name) file_pos)
    ))
    let. C_Context(context_vars _) context
    for_ι(-(len[#(List(Int) C_Variable)](context_vars) old_context_len) λ.(i 'Int
        let. #(_ var) get[#(List(Int) C_Variable)](context_vars +(i old_context_len))
        codegen_var_rc_decr(var)
    ))
    match. block_val
    .Some(block_val) block_val
    .None() codegen_tuple(list→vector(empty[Int]))

set. codegen_pattern_test λ.{val 'Int pattern 'T_Pattern context 'C_Context}
    let. T_Pattern(pattern_data _ file_pos) pattern
    match. pattern_data
    .T_IntLiteralPattern(n) #(empty[#(List(Int) C_Variable)] list.(codegen_int_pattern_test(val n)))
    .T_IdentPattern(name) #(list.(#(name C_ConstVar(val))) empty[Int])
    .T_WildcardPattern() #(empty[#(List(Int) C_Variable)] empty[Int])
    .T_TuplePattern(patterns)
        let. tuple codegen_tuple_cast(val len[T_Pattern](patterns))
        let. #(bindings_ ends_) unzip[List(#(List(Int) C_Variable)) List(Int)](map_ι[#(List(#(List(Int) C_Variable)) List(Int))](len[T_Pattern](patterns) λ.(i 'Int
            codegen_pattern_test(codegen_tuple_get(tuple i) get[T_Pattern](patterns i) context)
        )))
        #(concat[#(List(Int) C_Variable)](bindings_) concat[Int](ends_))
    .T_VariantPattern(ctor patterns _)
        let. tag match. c_lookup_var(ctor context)
            .C_Ctor(_ tag) tag
            .C_DCtor(tag) tag
            ._
                error(NotACtor(ctor) file_pos)
                None[Int]()
        match. tag
        .Some(tag)
            let. tagged codegen_tagged_cast(val len[T_Pattern](patterns))
            let. tag_fail codegen_tag_check(tagged tag)
            let. #(bindings_ ends_) unzip[List(#(List(Int) C_Variable)) List(Int)](map_ι[#(List(#(List(Int) C_Variable)) List(Int))](len[T_Pattern](patterns) λ.(i 'Int
                codegen_pattern_test(codegen_tuple_get(tagged i) get[T_Pattern](patterns i) context)
            )))
            #(concat[#(List(Int) C_Variable)](bindings_) push[Int](concat[Int](ends_) tag_fail))
        .None()
            let. tuple codegen_tuple_cast(val len[T_Pattern](patterns))
            let. #(bindings_ ends_) unzip[List(#(List(Int) C_Variable)) List(Int)](map_ι[#(List(#(List(Int) C_Variable)) List(Int))](len[T_Pattern](patterns) λ.(i 'Int
                codegen_pattern_test(codegen_tuple_get(tuple i) get[T_Pattern](patterns i) context)
            )))
            #(concat[#(List(Int) C_Variable)](bindings_) concat[Int](ends_))
    .T_ListPattern(patterns)
        let. list codegen_list_cast(val)
        let. len_fail codegen_len_check(list len[T_Pattern](patterns))
        let. #(bindings_ ends_) unzip[List(#(List(Int) C_Variable)) List(Int)](map_ι[#(List(#(List(Int) C_Variable)) List(Int))](len[T_Pattern](patterns) λ.(i 'Int
            codegen_pattern_test(codegen_list_get(list i) get[T_Pattern](patterns i) context)
        )))
        #(concat[#(List(Int) C_Variable)](bindings_) push[Int](concat[Int](ends_) len_fail))
