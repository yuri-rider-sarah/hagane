extern. get_insert_block ‡(: Int)
extern. set_insert_block ‡(Int : #())
extern. create_block ‡(: Int)
extern. begin_new_function ‡(Int : Int)
extern. codegen_rc_incr ‡(Int : #())
extern. codegen_rc_decr ‡(Int : #())
extern. codegen_const_bool ‡(Int : Int)
extern. codegen_const_int ‡(Int : Int)
extern. codegen_tuple ‡(Int : Int)
extern. codegen_list ‡(Int : Int)
extern. codegen_cell_rc_incr ‡(Int : #())
extern. codegen_cell_rc_decr ‡(Int : #())
extern. codegen_create_mut_var ‡(Int : Int)
extern. codegen_load_mut_var ‡(Int : Int)
extern. codegen_store_mut_var ‡(Int Int : #())
extern. codegen_unreachable ‡(: #())
extern. codegen_br ‡(Int : #())
extern. codegen_cond_br ‡(Int Int Int : #())
extern. codegen_phi ‡(Int : Int)
extern. phi_add_incoming ‡(Int Int Int : #())
extern. codegen_apply ‡(Int Int : Int)
extern. codegen_get_arg ‡(Int : Int)
extern. get_captures_type ‡(Int Int : Int)
extern. codegen_get_captures ‡(: Int)
extern. codegen_pointer_bitcast ‡(Int Int : Int)
extern. codegen_extract_capture ‡(Int Int : Int)
extern. codegen_ret ‡(Int : #())
extern. codegen_func_val ‡(Int Int Int : Int)
extern. codegen_create_tagless_ctor ‡(Int : Int)
extern. codegen_create_tagged_ctor ‡(Int Int : Int)
extern. bind_pattern_end ‡(Int Int : #())
extern. codegen_int_pattern_test ‡(Int Int : Int)
extern. codegen_tuple_cast ‡(Int Int : Int)
extern. codegen_tagged_cast ‡(Int Int : Int)
extern. codegen_tag_check ‡(Int Int : Int)
extern. codegen_tuple_get ‡(Int Int : Int)
extern. codegen_list_cast ‡(Int : Int)
extern. codegen_len_check ‡(Int Int : Int)
extern. codegen_list_get ‡(Int Int : Int)
extern. codegen_extern ‡(Int Int Int : Int)
extern. codegen_arith_primitive ‡(Int : Int)
extern. codegen_div_primitive ‡(Int : Int)
extern. codegen_cmp_primitive ‡(Int : Int)
extern. codegen_len_primitive ‡(: Int)
extern. codegen_get_primitive ‡(: Int)
extern. codegen_put_primitive ‡(: Int)
extern. codegen_push_primitive ‡(: Int)
extern. codegen_pop_primitive ‡(: Int)

let. begin_new_block λ.{}
    let. bb create_block()
    set_insert_block(bb)
    bb

type. C_Variable
    C_ConstVar(Int)
    C_MutVar(Int)
    C_Ctor(Int Option(Int))
    C_Unused()
    C_DCtor(Option(Int))

let. codegen_var_rc_decr λ.{var 'C_Variable}
    match. var
    .C_ConstVar(val) codegen_rc_decr(val)
    .C_MutVar(var) codegen_cell_rc_decr(var)
    .C_Ctor(val _) codegen_rc_decr(val)
    .C_Unused() #()
    .C_DCtor(_) #()

let. codegen_var_rc_incr λ.{var 'C_Variable}
    match. var
    .C_ConstVar(val) codegen_rc_incr(val)
    .C_MutVar(var) codegen_cell_rc_incr(var)
    .C_Ctor(val _) codegen_rc_incr(val)
    .C_Unused() #()
    .C_DCtor(_) #()

type. C_Context C_Context(
    List(#(List(Int) C_Variable))         ※ vars
    List(#(List(Int) List(List(T_Type)))) ※ types
)

let. c_add_let_binding λ.{context 'C_Context name 'List(Int) var 'C_Variable}
    let. C_Context(vars types) context
    C_Context(push(vars #(name var)) types)

let. c_add_type_binding λ.{context 'C_Context type_params 'List(Int) variants 'List(List(T_Type))}
    let. C_Context(vars types) context
    C_Context(vars push(types #(type_params variants)))

let. c_lookup_var λ.{name 'List(Int) context 'C_Context}
    let. mut, r None()
    let. C_Context(vars _) context
    for(vars λ.(var '#(List(Int) C_Variable)
        let. #(name′ val) var
        if. =list(name′ name =)
        then, set. r Some(val)
        else, #()
    ))
    match. r
    .Some(val) val
    .None()
        unreachable("Variable not found in context")
        C_ConstVar(0)

let. extern_binding λ.{name 'List(Int) num_params 'Int ret_int 'Int}
    #(name C_ConstVar(codegen_extern(list→vector(name) num_params ret_int)))

let. get_empty_c_context λ.{}
    C_Context(
        list.(
        #("⊤" C_ConstVar(codegen_const_bool(1)))
        #("⊥" C_ConstVar(codegen_const_bool(0)))
        #("+" C_ConstVar(codegen_arith_primitive(0)))
        #("-" C_ConstVar(codegen_arith_primitive(1)))
        #("*" C_ConstVar(codegen_arith_primitive(2)))
        #("/" C_ConstVar(codegen_div_primitive(0)))
        #("%" C_ConstVar(codegen_div_primitive(1)))
        #("=" C_ConstVar(codegen_cmp_primitive(0)))
        #("≠" C_ConstVar(codegen_cmp_primitive(1)))
        #("<" C_ConstVar(codegen_cmp_primitive(2)))
        #("≤" C_ConstVar(codegen_cmp_primitive(3)))
        #(">" C_ConstVar(codegen_cmp_primitive(4)))
        #("≥" C_ConstVar(codegen_cmp_primitive(5)))
        #("empty" C_ConstVar(codegen_list(list→vector(empty))))
        #("len" C_ConstVar(codegen_len_primitive()))
        #("get" C_ConstVar(codegen_get_primitive()))
        #("put" C_ConstVar(codegen_put_primitive()))
        #("push" C_ConstVar(codegen_push_primitive()))
        #("pop" C_ConstVar(codegen_pop_primitive()))
        extern_binding("print_int" 1 0)
        extern_binding("read_int" 0 1)
        extern_binding("print_byte" 1 0)
        extern_binding("read_byte" 0 1)
        extern_binding("get_argc" 0 1)
        extern_binding("get_argv_len" 1 1)
        extern_binding("get_argv_byte" 2 1)
        )
        list.(#(empty list.(empty)) #(empty list.(empty)) #(list.(3) list.(empty)))
    )

let. mut, c_substitute_in_type λ.{type 'T_Type subs 'List(#(Int T_Type))} type
set. c_substitute_in_type λ.{type 'T_Type subs 'List(#(Int T_Type))}
    match. type
    .T_Named(tn type_args)
        let. mut, t′ None()
        for(subs λ.(sub '#(Int T_Type)
            let. #(stn st) sub
            if. =(stn tn)
            then, set. t′ Some(st)
            else, #()
        ))
        match. t′
        .Some(t′) t′
        .None() T_Named(tn map(type_args λ.(t 'T_Type c_substitute_in_type(t subs))))
    .T_TupleType(subtypes) T_TupleType(map(subtypes λ.(t 'T_Type c_substitute_in_type(t subs))))
    .T_Function(params ret) T_Function(map(params λ.(t 'T_Type c_substitute_in_type(t subs))) c_substitute_in_type(ret subs))

let. mut, is_match_exhaustive λ.{pattern_lists 'List(List(T_Pattern)) types 'List(T_Type) context 'C_Context} ⊥
set. is_match_exhaustive λ.{pattern_lists 'List(List(T_Pattern)) types 'List(T_Type) context 'C_Context}
    if. =(len(types) 0)
    then, ≠(len(pattern_lists) 0)
    else,
        let. pattern_lists′ map_opt(pattern_lists λ.(ps 'List(T_Pattern)
            let. T_Pattern(pd _ _) get(ps 0)
            match. pd
            .T_IdentPattern(_) Some(drop(ps 1))
            .T_WildcardPattern() Some(drop(ps 1))
            ._ None()
        ))
        if. ≠(len(pattern_lists′) 0)
        then, is_match_exhaustive(pattern_lists′ drop(types 1) context)
        else, match. get(types 0)
            .T_Named(ti type_args)
                let. C_Context(_ ctx_types) context
                let. #(type_params variants) get(ctx_types ti)
                let. subs match. zip(type_params type_args)
                    .Some(subs) subs
                    .None()
                        unreachable("type_args and type_params are not equal length")
                        empty
                let. variants map(variants λ.(variant 'List(T_Type)
                    map(variant λ.(t 'T_Type c_substitute_in_type(t subs)))
                ))
                ∀(ι*(variants) λ.(vs '#(Int List(T_Type))
                    let. #(vi subtypes) vs
                    let. pattern_lists′ map_opt(pattern_lists λ.(ps 'List(T_Pattern)
                        match. get(ps 0)
                        .T_Pattern(T_VariantPattern(name subpatterns _) _ file_pos) match. c_lookup_var(name context)
                            .C_Ctor(_ vi′) if. =(default(0 vi′) vi)
                                then, Some(++(subpatterns drop(ps 1)))
                                else, None()
                            .C_DCtor(vi′) if. =(default(0 vi′) vi)
                                then, Some(++(subpatterns drop(ps 1)))
                                else, None()
                            ._
                                error(NotACtor(name) file_pos)
                                None()
                        ._ None()
                    ))
                    if. ≠(len(pattern_lists′) 0)
                    then, is_match_exhaustive(pattern_lists′ ++(subtypes drop(types 1)) context)
                    else, ⊥
                ))
            .T_TupleType(subtypes)
                let. pattern_lists′ map_opt(pattern_lists λ.(ps 'List(T_Pattern)
                    match. get(ps 0)
                    .T_Pattern(T_TuplePattern(subpatterns) _ _)
                        Some(++(subpatterns drop(ps 1)))
                    ._ None()
                ))
                if. ≠(len(pattern_lists′) 0)
                then, is_match_exhaustive(pattern_lists′ ++(subtypes drop(types 1)) context)
                else, ⊥
            .T_Function(_ _) ⊥

let. mut, pattern_vars λ.{pattern 'T_Pattern} empty
set. pattern_vars λ.{pattern 'T_Pattern}
    let. rec λ. subpatterns 'List(T_Pattern) dedup(concat(map(subpatterns pattern_vars)) =list_int)
    let. T_Pattern(pattern_data _ _) pattern
    match. pattern_data
    .T_IntLiteralPattern(_) empty
    .T_IdentPattern(name) list.(name)
    .T_WildcardPattern() empty
    .T_TuplePattern(subpatterns) rec(subpatterns)
    .T_VariantPattern(_ subpatterns _) rec(subpatterns)
    .T_ListPattern(subpatterns) rec(subpatterns)

let. mut, free_vars λ.{expr 'T_Expr} empty
set. free_vars λ.{expr 'T_Expr}
    let. rec λ. subexprs 'List(T_Expr) dedup(concat(map(subexprs free_vars)) =list_int)
    let. T_Expr(expr_data _ _) expr
    match. expr_data
    .T_IntLiteral(_) empty
    .T_Ident(name _) list.(name)
    .T_Tuple(subexprs) rec(subexprs)
    .T_Apply(func args) rec(push(args func))
    .T_Set(name subexpr) push(free_vars(subexpr) name)
    .T_If(cases else) rec(++(concat(map(cases λ.(#(cond body) list.(cond body)))) list.(else)))
    .T_While(cond body) rec(list.(cond body))
    .T_Do(statements)
        let. mut, bound_vars empty
        let. mut, do_free_vars empty
        for(statements λ.(statement 'T_Statement
            let. T_Statement(statement_data _) statement
            match. statement_data
            .T_ExprStatement(expr) set. do_free_vars ++(do_free_vars \(free_vars(expr) bound_vars =list_int))
            .T_Let(pattern expr)
                set. do_free_vars ++(do_free_vars \(free_vars(expr) bound_vars =list_int))
                set. bound_vars ++(bound_vars pattern_vars(pattern))
            .T_Let∀(_ name expr)
                set. do_free_vars ++(do_free_vars \(free_vars(expr) bound_vars =list_int))
                set. bound_vars push(bound_vars name)
            .T_LetMut(name expr)
                set. do_free_vars ++(do_free_vars \(free_vars(expr) bound_vars =list_int))
                set. bound_vars push(bound_vars name)
            .T_TypeStatement(_ _) #()
            .T_Extern(name _)
                set. bound_vars push(bound_vars name)
        ))
        dedup(do_free_vars =list_int)
    .T_Lambda(params body) \(free_vars(body) concat(map(params pattern_vars)) =list_int)
    .T_Case(subexpr cases) dedup(concat(push(map(cases λ.(case '#(T_Pattern T_Expr)
        let. #(pattern body) case
        \(free_vars(body) pattern_vars(pattern) =list_int)
    )) free_vars(subexpr))) =list_int)
    .T_And(subexprs) rec(subexprs)
    .T_Or(subexprs) rec(subexprs)
    .T_ListLiteral(subexprs) rec(subexprs)

let. mut, codegen_expr λ.{expr 'T_Expr context 'C_Context} 0
let. mut, codegen_statements λ.{statements 'List(T_Statement) context 'C_Context} 0
let. mut, codegen_pattern_test λ.{val 'Int pattern 'T_Pattern context 'C_Context} #(empty empty)

set. codegen_expr λ.{expr 'T_Expr context 'C_Context}
    let. T_Expr(expr_data expr_type file_pos) expr
    match. expr_data
    .T_IntLiteral(n) codegen_const_int(n)
    .T_Ident(name _)
        let. val match. c_lookup_var(name context)
            .C_ConstVar(val) val
            .C_MutVar(var) codegen_load_mut_var(var)
            .C_Ctor(ctor _) ctor
            .C_Unused()
                unreachable("Variable incorrectly marked as unused")
                0
            .C_DCtor(_)
                unreachable("Variable incorrectly marked as unused")
                0
        codegen_rc_incr(val)
        val
    .T_Tuple(exprs)
        codegen_tuple(list→vector(map(exprs λ.(e 'T_Expr codegen_expr(e context)))))
    .T_Apply(func args)
        codegen_apply(codegen_expr(func context) list→vector(map(args λ.(e 'T_Expr codegen_expr(e context)))))
    .T_Set(name expr)
        match. c_lookup_var(name context)
        .C_MutVar(var)
            let. val codegen_expr(expr context)
            codegen_rc_decr(codegen_load_mut_var(var))
            codegen_store_mut_var(var val)
        .C_Unused()
            unreachable("Variable incorrectly marked as unused")
        ._ error(AssignToConst(name) file_pos)
        codegen_tuple(list→vector(empty))
    .T_If(cases else)
        let. branches map(cases λ.(case
            let. #(cond body) case
            let. cond_val codegen_expr(cond context)
            let. cond_val_block get_insert_block()
            let. body_block begin_new_block()
            let. body_val codegen_expr(body context)
            let. body_end get_insert_block()
            let. next_block create_block()
            set_insert_block(cond_val_block)
            codegen_cond_br(cond_val body_block next_block)
            set_insert_block(next_block)
            #(body_val body_end)
        ))
        let. else_val codegen_expr(else context)
        let. else_end get_insert_block()
        let. merge_block begin_new_block()
        let. phi codegen_phi(len(branches))
        for(branches λ.(#(body_val body_end)
            set_insert_block(body_end)
            codegen_br(merge_block)
            phi_add_incoming(phi body_val body_end)
        ))
        set_insert_block(else_end)
        codegen_br(merge_block)
        phi_add_incoming(phi else_val else_end)
        set_insert_block(merge_block)
        phi
    .T_And(subexprs)
        let. branches map(subexprs λ.(cond
            let. cond_val codegen_expr(cond context)
            let. cond_end get_insert_block()
            let. next_block begin_new_block()
            #(cond_val cond_end next_block)
        ))
        let. true_block get_insert_block()
        let. true_val codegen_const_bool(1)
        let. false_block begin_new_block()
        let. false_val codegen_const_bool(0)
        for(branches λ.(#(cond_val cond_end next_block)
            set_insert_block(cond_end)
            codegen_cond_br(cond_val next_block false_block)
        ))
        let. merge_block begin_new_block()
        let. phi codegen_phi(2)
        set_insert_block(true_block)
        codegen_br(merge_block)
        set_insert_block(false_block)
        codegen_br(merge_block)
        phi_add_incoming(phi true_val true_block)
        phi_add_incoming(phi false_val false_block)
        set_insert_block(merge_block)
        phi
    .T_Or(subexprs)
        let. branches map(subexprs λ.(cond
            let. cond_val codegen_expr(cond context)
            let. cond_end get_insert_block()
            let. next_block begin_new_block()
            #(cond_val cond_end next_block)
        ))
        let. false_block get_insert_block()
        let. false_val codegen_const_bool(0)
        let. true_block begin_new_block()
        let. true_val codegen_const_bool(1)
        for(branches λ.(#(cond_val cond_end next_block)
            set_insert_block(cond_end)
            codegen_cond_br(cond_val true_block next_block)
        ))
        let. merge_block begin_new_block()
        let. phi codegen_phi(2)
        set_insert_block(false_block)
        codegen_br(merge_block)
        set_insert_block(true_block)
        codegen_br(merge_block)
        phi_add_incoming(phi false_val false_block)
        phi_add_incoming(phi true_val true_block)
        set_insert_block(merge_block)
        phi
    .T_While(cond body)
        let. cond_block create_block()
        codegen_br(cond_block)
        set_insert_block(cond_block)
        let. cond_val codegen_expr(cond context)
        let. cond_val_block get_insert_block()
        let. body_block begin_new_block()
        codegen_rc_decr(codegen_expr(body context))
        codegen_br(cond_block)
        let. merge_block create_block()
        set_insert_block(cond_val_block)
        codegen_cond_br(cond_val body_block merge_block)
        set_insert_block(merge_block)
        codegen_tuple(list→vector(empty))
    .T_Do(statements) codegen_statements(statements context)
    .T_Lambda(params body)
        let. parent_block get_insert_block()
        let. C_Context(vars types) context
        let. body_free_vars free_vars(body)
        let. mut, is_captured empty
        for(vars λ.(var '#(List(Int) C_Variable) set.(is_captured push(is_captured ⊥))))
        for(body_free_vars λ.(name 'List(Int)
            let. mut, cap_var_i None()
            for_ι(len(vars) λ.(i 'Int
                let. #(name′ _) get(vars i)
                if. =list(name′ name =)
                    set. cap_var_i Some(i)
                else, #()
            ))
            match. cap_var_i
            .Some(cap_var_i)
                set. is_captured put(is_captured cap_var_i ⊤)
            .None() #()
        ))
        let. outer_captures list→vector(map_opt(ι*(vars) λ.(i_var '#(Int #(List(Int) C_Variable))
            let. #(i #(name var)) i_var
            if. get(is_captured i)
                let. cap match. var
                    .C_ConstVar(val)
                        codegen_rc_incr(val)
                        val
                    .C_MutVar(ptr)
                        codegen_cell_rc_incr(ptr)
                        ptr
                    .C_Ctor(ctor _)
                        codegen_rc_incr(ctor)
                        ctor
                    .C_Unused()
                        unreachable("Variable incorrectly marked as unused")
                        0
                    .C_DCtor(_)
                        unreachable("Variable incorrectly marked as unused")
                        0
                Some(cap)
            else, None()
        )))
        let. captures_type get_captures_type(len(params) outer_captures)
        let. func begin_new_function(len(params))
        let. inner_captures_box codegen_get_captures()
        let. inner_captures codegen_pointer_bitcast(inner_captures_box captures_type)
        let. mut, cap_struct_i 0
        let. vars′ ++(
            map(ι*(vars) λ.(i_var '#(Int #(List(Int) C_Variable))
                let. #(i #(name var)) i_var
                if. get(is_captured i)
                    let. cap codegen_extract_capture(inner_captures cap_struct_i)
                    set. cap_struct_i +(cap_struct_i 1)
                    let. var′ match. var
                        .C_ConstVar(_) C_ConstVar(cap)
                        .C_MutVar(_) C_MutVar(cap)
                        .C_Ctor(_ tag) C_Ctor(cap tag)
                        .C_Unused()
                            unreachable("Variable incorrectly marked as unused")
                            C_Unused()
                        .C_DCtor(tag) C_DCtor(tag)
                    codegen_var_rc_incr(var′)
                    #(name var′)
                else,
                    let. var′ match. var
                        .C_Ctor(_ tag) C_DCtor(tag)
                        .C_DCtor(tag) C_DCtor(tag)
                        ._ C_Unused()
                    #(name var′)
            ))
            concat(map_ι(len(params) λ.(i 'Int
                let. arg codegen_get_arg(i)
                let. #(bindings pattern_ends) codegen_pattern_test(arg get(params i) context)
                if. ≠(len(pattern_ends) 0)
                    unreachable("pattern_ends not empty")
                else, #()
                for(bindings λ.(binding '#(List(Int) C_Variable)
                    let. #(_ var) binding
                    codegen_var_rc_incr(var)
                ))
                codegen_rc_decr(arg)
                bindings
            )))
        )
        let. context′ C_Context(vars′ types)
        codegen_rc_decr(inner_captures_box)
        let. ret_val codegen_expr(body context′)
        for(vars′ λ.(binding '#(List(Int) C_Variable)
            let. #(_ var) binding
            codegen_var_rc_decr(var)
        ))
        codegen_ret(ret_val)
        set_insert_block(parent_block)
        codegen_func_val(func outer_captures captures_type)
    .T_Case(expr cases)
        let. T_Expr(_ expr_type expr_file_pos) expr
        if. ¬(is_match_exhaustive(map(cases λ.(case '#(T_Pattern T_Expr)
            let. #(pattern _) case
            list.(pattern)
        )) list.(expr_type) context))
        then, error(InexhaustivePatterns() expr_file_pos)
        else, #()
        let. C_Context(old_context_vars _) context
        let. old_context_len len(old_context_vars)
        let. matched_val codegen_expr(expr context)
        let. branches map(cases λ.(case '#(T_Pattern T_Expr)
            let. #(pattern body) case
            let. #(bindings pattern_ends) codegen_pattern_test(matched_val pattern context)
            let. mut, context′ context
            for(bindings λ.(bind '#(List(Int) C_Variable)
                let. #(name var) bind
                codegen_var_rc_incr(var)
                set. context′ c_add_let_binding(context′ name var)
            ))
            codegen_rc_decr(matched_val)
            let. body_val codegen_expr(body context′)
            let. C_Context(context_vars _) context
            for_ι(-(len(context_vars) old_context_len) λ.(i 'Int
                let. #(_ var) get(context_vars +(i old_context_len))
                codegen_var_rc_decr(var)
            ))
            let. body_end get_insert_block()
            let. next_block create_block()
            for(pattern_ends λ.(pattern_end 'Int
                bind_pattern_end(pattern_end next_block)
            ))
            set_insert_block(next_block)
            #(body_val body_end)
        ))
        codegen_unreachable()
        let. merge_block begin_new_block()
        let. phi codegen_phi(len(branches))
        for(branches λ.(branch '#(Int Int)
            let. #(body_val body_end) branch
            set_insert_block(body_end)
            codegen_br(merge_block)
            phi_add_incoming(phi body_val body_end)
        ))
        set_insert_block(merge_block)
        phi
    .T_ListLiteral(exprs)
        codegen_list(list→vector(map(exprs λ.(e 'T_Expr codegen_expr(e context)))))

set. codegen_statements λ.{statements 'List(T_Statement) context 'C_Context}
    let. mut, context context
    let. C_Context(old_context_vars old_context_types) context
    let. old_context_len len(old_context_vars)
    let. mut, type_index_base len(old_context_types)
    for(statements λ.(statement 'T_Statement
        match. statement
        .T_Statement(T_TypeStatement(num_type_params variants) _) set. type_index_base +(type_index_base 1)
        ._ #()
    ))
    for(statements λ.(statement 'T_Statement
        match. statement
        .T_Statement(T_TypeStatement(num_type_params variants) _) set. context c_add_type_binding(context
            map_ι(num_type_params λ.(i 'Int +(type_index_base i)))
            map(variants λ.(v '#(List(Int) List(T_Type))
                let. #(_ v) v
                v
            ))
        )
        ._ #()
    ))
    let. mut, block_val None()
    for(statements λ.(statement 'T_Statement
        let. T_Statement(statement_data file_pos) statement
        match. statement_data
        .T_ExprStatement(expr)
            match. block_val
            .Some(val) codegen_rc_decr(val)
            .None() #()
            set. block_val Some(codegen_expr(expr context))
        .T_Let(pattern expr)
            let. T_Expr(_ expr_type _) expr
            if. ¬(is_match_exhaustive(list.(list.(pattern)) list.(expr_type) context))
            then, error(InexhaustivePatterns() file_pos)
            else, #()
            let. val codegen_expr(expr context)
            let. #(bindings pattern_ends) codegen_pattern_test(val pattern context)
            if. ≠(len(pattern_ends) 0)
                unreachable("pattern_ends not empty")
            else, #()
            for(bindings λ.(bind '#(List(Int) C_Variable)
                let. #(name var) bind
                codegen_var_rc_incr(var)
                set. context c_add_let_binding(context name var)
            ))
            codegen_rc_decr(val)
        .T_Let∀(type_params name expr)
            let. mut, context′ context
            for_ι(type_params λ.(i 'Int set.(context′ c_add_type_binding(context′ empty list.(empty)))))
            set. context c_add_let_binding(context name C_ConstVar(codegen_expr(expr context)))
        .T_LetMut(name expr)
            set. context c_add_let_binding(context name C_MutVar(codegen_create_mut_var(codegen_expr(expr context))))
        .T_TypeStatement(num_params variants)
            if. =(len(variants) 1)
                let. #(name params) get(variants 0)
                set. context c_add_let_binding(context name C_Ctor(codegen_create_tagless_ctor(len(params)) None()))
            else,
                for_ι(len(variants) λ.(i 'Int
                    let. #(name params) get(variants i)
                    set. context c_add_let_binding(context name C_Ctor(codegen_create_tagged_ctor(len(params) i) Some(i)))
                ))
        .T_Extern(name type)
            match. type
            .T_Function(params ret)
                let. TypeName(int_type_index) int_type
                for(params λ.(param 'T_Type
                    match. param
                    .T_Named(i _)
                        if. ≠(i int_type_index)
                            error(InvalidExternType(name) file_pos)
                        else, #()
                    ._
                        error(InvalidExternType(name) file_pos)
                ))
                let. ret_int match. ret
                    .T_Named(i _)
                        if. ≠(i int_type_index)
                            error(InvalidExternType(name) file_pos)
                        else, #()
                        ⊤
                    .T_TupleType(list.()) ⊥
                    ._
                        error(InvalidExternType(name) file_pos)
                        ⊥
                set. context c_add_let_binding(context name C_ConstVar(codegen_extern(utf8_encode(list→vector(name)) len(params) if.(ret_int 1 0))))
            ._
                error(InvalidExternType(name) file_pos)
    ))
    let. C_Context(context_vars _) context
    for_ι(-(len(context_vars) old_context_len) λ.(i 'Int
        let. #(_ var) get(context_vars +(i old_context_len))
        codegen_var_rc_decr(var)
    ))
    match. block_val
    .Some(block_val) block_val
    .None() codegen_tuple(list→vector(empty))

set. codegen_pattern_test λ.{val 'Int pattern 'T_Pattern context 'C_Context}
    let. T_Pattern(pattern_data _ file_pos) pattern
    match. pattern_data
    .T_IntLiteralPattern(n) #(empty list.(codegen_int_pattern_test(val n)))
    .T_IdentPattern(name) #(list.(#(name C_ConstVar(val))) empty)
    .T_WildcardPattern() #(empty empty)
    .T_TuplePattern(patterns)
        let. tuple codegen_tuple_cast(val len(patterns))
        let. #(bindings_ ends_) unzip(map_ι(len(patterns) λ.(i 'Int
            codegen_pattern_test(codegen_tuple_get(tuple i) get(patterns i) context)
        )))
        #(concat(bindings_) concat(ends_))
    .T_VariantPattern(ctor patterns _)
        let. tag match. c_lookup_var(ctor context)
            .C_Ctor(_ tag) tag
            .C_DCtor(tag) tag
            ._
                error(NotACtor(ctor) file_pos)
                None()
        match. tag
        .Some(tag)
            let. tagged codegen_tagged_cast(val len(patterns))
            let. tag_fail codegen_tag_check(tagged tag)
            let. #(bindings_ ends_) unzip(map_ι(len(patterns) λ.(i 'Int
                codegen_pattern_test(codegen_tuple_get(tagged i) get(patterns i) context)
            )))
            #(concat(bindings_) push(concat(ends_) tag_fail))
        .None()
            let. tuple codegen_tuple_cast(val len(patterns))
            let. #(bindings_ ends_) unzip(map_ι(len(patterns) λ.(i 'Int
                codegen_pattern_test(codegen_tuple_get(tuple i) get(patterns i) context)
            )))
            #(concat(bindings_) concat(ends_))
    .T_ListPattern(patterns)
        let. list codegen_list_cast(val)
        let. len_fail codegen_len_check(list len(patterns))
        let. #(bindings_ ends_) unzip(map_ι(len(patterns) λ.(i 'Int
            codegen_pattern_test(codegen_list_get(list i) get(patterns i) context)
        )))
        #(concat(bindings_) push(concat(ends_) len_fail))
