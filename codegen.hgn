extern. get_insert_block ⇒.(: Int)
extern. set_insert_block ⇒.(Int : *.())
extern. create_block ⇒.(: Int)
extern. begin_new_function ⇒.(Int : Int)
extern. codegen_rc_incr ⇒.(Int : *.())
extern. codegen_rc_decr ⇒.(Int : *.())
extern. codegen_const_bool ⇒.(Int : Int)
extern. codegen_const_int ⇒.(Int : Int)
extern. codegen_tuple ⇒.(Int : Int)
extern. codegen_list ⇒.(Int : Int)
extern. codegen_cell_rc_incr ⇒.(Int : *.())
extern. codegen_cell_rc_decr ⇒.(Int : *.())
extern. codegen_create_mut_var ⇒.(Int : Int)
extern. codegen_load_mut_var ⇒.(Int : Int)
extern. codegen_store_mut_var ⇒.(Int Int : *.())
extern. codegen_unreachable ⇒.(: *.())
extern. codegen_br ⇒.(Int : *.())
extern. codegen_cond_br ⇒.(Int Int Int : *.())
extern. codegen_phi ⇒.(Int : Int)
extern. phi_add_incoming ⇒.(Int Int Int : *.())
extern. codegen_apply ⇒.(Int Int : Int)
extern. codegen_get_arg ⇒.(Int : Int)
extern. get_captures_type ⇒.(Int Int : Int)
extern. codegen_get_captures ⇒.(: Int)
extern. codegen_pointer_bitcast ⇒.(Int Int : Int)
extern. codegen_extract_capture ⇒.(Int Int : Int)
extern. codegen_ret ⇒.(Int : *.())
extern. codegen_func_val ⇒.(Int Int Int : Int)
extern. codegen_null ⇒.(: Int)
extern. codegen_set_capture ⇒.(Int Int Int Int: *.())
extern. codegen_create_tagless_ctor ⇒.(Int : Int)
extern. codegen_create_tagged_ctor ⇒.(Int Int : Int)
extern. bind_pattern_end ⇒.(Int Int : *.())
extern. codegen_int_pattern_test ⇒.(Int Int : Int)
extern. codegen_tuple_cast ⇒.(Int Int : Int)
extern. codegen_tagged_cast ⇒.(Int Int : Int)
extern. codegen_tag_check ⇒.(Int Int : Int)
extern. codegen_tuple_get ⇒.(Int Int : Int)
extern. codegen_list_cast ⇒.(Int : Int)
extern. codegen_len_check ⇒.(Int Int : Int)
extern. codegen_list_get ⇒.(Int Int : Int)
extern. codegen_extern ⇒.(Int Int Int : Int)
extern. codegen_arith_primitive ⇒.(Int : Int)
extern. codegen_div_primitive ⇒.(Int : Int)
extern. codegen_cmp_primitive ⇒.(Int : Int)
extern. codegen_len_primitive ⇒.(: Int)
extern. codegen_get_primitive ⇒.(: Int)
extern. codegen_put_primitive ⇒.(: Int)
extern. codegen_push_primitive ⇒.(: Int)
extern. codegen_pop_primitive ⇒.(: Int)
extern. codegen_unreachable_primitive ⇒.(: Int)

let. begin_new_block λ.:
    let. bb create_block()
    set_insert_block(bb)
    bb

type. C_Variable
    C_ConstVar(Int)
    C_MutVar(Int)
    C_Ctor(Int Option(Int))
    C_Unused
    C_DCtor(Option(Int))

let. codegen_var_rc_decr λ. ∈.(var C_Variable):
    case. var
    .C_ConstVar(val) codegen_rc_decr(val)
    .C_MutVar(var) codegen_cell_rc_decr(var)
    .C_Ctor(val _) codegen_rc_decr(val)
    .C_Unused *.()
    .C_DCtor(_) *.()

let. codegen_var_rc_incr λ. ∈.(var C_Variable):
    case. var
    .C_ConstVar(val) codegen_rc_incr(val)
    .C_MutVar(var) codegen_cell_rc_incr(var)
    .C_Ctor(val _) codegen_rc_incr(val)
    .C_Unused *.()
    .C_DCtor(_) *.()

type. C_Context C_Context‡
    List(C_Variable)                       ※ vars
    List(*.(List(Int) List(List(T_Type)))) ※ types

let. c_add_let_binding λ. ∈.(context C_Context) ∈.(var C_Variable):
    let. C_Context(vars types) context
    C_Context(push(vars var) types)

let. c_add_type_binding λ. ∈.(context C_Context) ∈.(type_params List(Int)) ∈.(variants List(List(T_Type))):
    let. C_Context(vars types) context
    C_Context(vars push(types *.(type_params variants)))

let. c_lookup_var λ. ∈.(vi Int) ∈.(context C_Context):
    let. C_Context(vars _) context
    get(vars vi)

let. extern_binding λ. ∈.(name List(Int)) ∈.(num_params Int) ∈.(ret_int Int):
    C_ConstVar(codegen_extern(list→vector(name) num_params ret_int))

let. get_empty_c_context λ.:
    C_Context‡
        list.
            C_Ctor(codegen_const_bool(1) Some(1))
            C_Ctor(codegen_const_bool(0) Some(0))
            C_ConstVar(codegen_arith_primitive(0))
            C_ConstVar(codegen_arith_primitive(1))
            C_ConstVar(codegen_arith_primitive(2))
            C_ConstVar(codegen_div_primitive(0))
            C_ConstVar(codegen_div_primitive(1))
            C_ConstVar(codegen_cmp_primitive(0))
            C_ConstVar(codegen_cmp_primitive(1))
            C_ConstVar(codegen_cmp_primitive(2))
            C_ConstVar(codegen_cmp_primitive(3))
            C_ConstVar(codegen_cmp_primitive(4))
            C_ConstVar(codegen_cmp_primitive(5))
            C_ConstVar(codegen_list(list→vector(list.())))
            C_ConstVar(codegen_len_primitive())
            C_ConstVar(codegen_get_primitive())
            C_ConstVar(codegen_put_primitive())
            C_ConstVar(codegen_push_primitive())
            C_ConstVar(codegen_pop_primitive())
            extern_binding("print_int" 1 0)
            extern_binding("read_int" 0 1)
            extern_binding("print_byte" 1 0)
            extern_binding("read_byte" 0 1)
            extern_binding("get_argc" 0 1)
            extern_binding("get_argv_len" 1 1)
            extern_binding("get_argv_byte" 2 1)
            C_ConstVar(codegen_unreachable_primitive())
        list.(*.(list.() list.(list.())) *.(list.() list.(list.() list.())) *.(list.(3) list.(list.())))

let. mut, c_substitute_in_type λ. ∈.(type T_Type) ∈.(subs List(*.(Int T_Type))): type
set. c_substitute_in_type λ. ∈.(type T_Type) ∈.(subs List(*.(Int T_Type))):
    case. type
    .T_Named(tn type_args)
        let. mut, t′ None
        for‡ subs λ. sub:
            let. *.(stn st) sub
            if. =(stn tn)
            then, set. t′ Some(st)
            else, *.()
        case. t′
        .Some(t′) t′
        .None T_Named(tn map(type_args λ.(t: c_substitute_in_type(t subs))))
    .T_TupleType(subtypes) T_TupleType(map(subtypes λ.(t: c_substitute_in_type(t subs))))
    .T_Function(params ret) T_Function(map(params λ.(t: c_substitute_in_type(t subs))) c_substitute_in_type(ret subs))

let. mut, is_match_exhaustive λ. ∈.(pattern_lists List(List(T_Pattern))) ∈.(types List(T_Type)) ∈.(context C_Context): ⊥
set. is_match_exhaustive λ. ∈.(pattern_lists List(List(T_Pattern))) ∈.(types List(T_Type)) ∈.(context C_Context):
    if. =(len(types) 0)
    then, ≠(len(pattern_lists) 0)
    else,
        let. pattern_lists′ map_opt‡ pattern_lists λ. ps:
            let. T_Pattern(pd _ _) get(ps 0)
            case. pd
            .T_IdentPattern Some(drop(ps 1))
            .T_WildcardPattern Some(drop(ps 1))
            ._ None
        ∨.(
        ∧.(≠(len(pattern_lists′) 0) is_match_exhaustive(pattern_lists′ drop(types 1) context))
        case. get(types 0)
            .T_Named(ti type_args)
                let. C_Context(_ ctx_types) context
                let. *.(type_params variants) get(ctx_types ti)
                let. subs case. zip(type_params type_args)
                    .Some(subs) subs
                    .None internal_error("type_args and type_params are not equal length")
                let. variants map‡ variants λ. variant:
                    map(variant λ.(t: c_substitute_in_type(t subs)))
                ∀‡ ι*(variants) λ. *.(vi subtypes):
                    let. pattern_lists′ map_opt‡ pattern_lists λ. ps:
                        case. get(ps 0)
                        .T_Pattern(T_VariantPattern(ctor_vi subpatterns _) _ file_pos) case. c_lookup_var(ctor_vi context)
                            .C_Ctor(_ vi′) if. =(default(0 vi′) vi)
                                then, Some(++(subpatterns drop(ps 1)))
                                else, None
                            .C_DCtor(vi′) if. =(default(0 vi′) vi)
                                then, Some(++(subpatterns drop(ps 1)))
                                else, None
                            ._
                                internal_error("Pattern is not a constructor, but was expected to be")
                        ._ None
                    if. ≠(len(pattern_lists′) 0)
                    then, is_match_exhaustive(pattern_lists′ ++(subtypes drop(types 1)) context)
                    else, ⊥
            .T_TupleType(subtypes)
                let. pattern_lists′ map_opt‡ pattern_lists λ. ps:
                    case. get(ps 0)
                    .T_Pattern(T_TuplePattern(subpatterns) _ _)
                        Some(++(subpatterns drop(ps 1)))
                    ._ None
                if. ≠(len(pattern_lists′) 0)
                then, is_match_exhaustive(pattern_lists′ ++(subtypes drop(types 1)) context)
                else, ⊥
            .T_Function(_ _) ⊥
        )

let. free_vars λ. ∈.(expr T_Expr) ∈.(length Int):
    let. mut, table list.()
    for_ι(length λ.(_: set. table push(table ⊥)))
    let. mut, rec λ. ∈.(expr T_Expr): *¡
    set. rec λ. ∈.(expr T_Expr):
        let. T_Expr(expr_data _ _) expr
        case. expr_data
        .T_IntLiteral(_) *¡
        .T_Ident(vi _)
            if. <(vi len(table))
            then, set. table put(table vi ⊤)
            else, *¡
        .T_Tuple(subexprs) for(subexprs rec)
        .T_Apply(func args) for(push(args func) rec)
        .T_If(cases else) for(++(concat(map(cases λ.(*.(cond body): list.(cond body)))) list.(else)) rec)
        .T_While(cond body) for(list.(cond body) rec)
        .T_Do(statements)
            for‡ statements λ. statement:
                let. T_Statement(statement_data _) statement
                case. statement_data
                .T_ExprStatement(expr) rec(expr)
                .T_Let(_ expr) rec(expr)
                .T_Let∀(_ expr) rec(expr)
                .T_LetMut(expr) rec(expr)
                .T_Fun(_ defs) for(defs λ.(*.(_ expr_): rec(expr_)))
                .T_TypeStatement(_ _) *¡
                .T_Extern(_ _) *¡
                .T_Set(vi subexpr)
                    if. <(vi len(table))
                    then, set. table put(table vi ⊤)
                    else, *¡
                    rec(subexpr)
        .T_Lambda(_ body) rec(body)
        .T_Case(subexpr cases)
            rec(subexpr)
            for(cases λ.(*.(_ body): rec(body)))
        .T_And(subexprs) for(subexprs rec)
        .T_Or(subexprs) for(subexprs rec)
        .T_ListLiteral(subexprs) for(subexprs rec)
    rec(expr)
    table

let. mut, codegen_expr λ. ∈.(expr T_Expr) ∈.(context C_Context): 0
let. mut, codegen_statements λ. ∈.(statements List(T_Statement)) ∈.(context C_Context): 0
let. mut, codegen_pattern_test λ. ∈.(val Int) ∈.(pattern T_Pattern) ∈.(context C_Context): *.(list.() list.())

let. codegen_outer_captures λ. ∈.(vars List(C_Variable)) ∈.(is_captured List(Bool)):
    map_opt‡ ι*(vars) λ. i_var:
        let. *.(i var) i_var
        if. get(is_captured i)
            let. cap case. var
                .C_ConstVar(val)
                    codegen_rc_incr(val)
                    val
                .C_MutVar(ptr)
                    codegen_cell_rc_incr(ptr)
                    ptr
                .C_Ctor(ctor _)
                    codegen_rc_incr(ctor)
                    ctor
                .C_Unused internal_error("Variable incorrectly marked as unused")
                .C_DCtor(_) internal_error("Variable incorrectly marked as unused")
            Some(cap)
        else, None

let. codegen_function λ.
    ∈.(params List(T_Pattern))
    ∈.(body T_Expr)
    ∈.(context C_Context)
    ∈.(is_captured List(Bool))
    ∈.(outer_captures Int)
    :
    let. C_Context(vars types) context
    let. parent_block get_insert_block()
    let. captures_type get_captures_type(len(params) outer_captures)
    let. func begin_new_function(len(params))
    let. inner_captures_box codegen_get_captures()
    let. inner_captures codegen_pointer_bitcast(inner_captures_box captures_type)
    let. mut, cap_struct_i 0
    let. vars′ ++‡
        map‡ ι*(vars) λ. *.(i var):
            if. get(is_captured i)
                let. cap codegen_extract_capture(inner_captures cap_struct_i)
                set. cap_struct_i +(cap_struct_i 1)
                let. var′ case. var
                    .C_ConstVar(_) C_ConstVar(cap)
                    .C_MutVar(_) C_MutVar(cap)
                    .C_Ctor(_ tag) C_Ctor(cap tag)
                    .C_Unused internal_error("Variable incorrectly marked as unused")
                    .C_DCtor(tag) C_DCtor(tag)
                codegen_var_rc_incr(var′)
                var′
            else,
                let. var′ case. var
                    .C_Ctor(_ tag) C_DCtor(tag)
                    .C_DCtor(tag) C_DCtor(tag)
                    ._ C_Unused
                var′
        concat‡ map_ι‡ len(params) λ. i:
            let. arg codegen_get_arg(i)
            let. *.(bound_vars pattern_ends) codegen_pattern_test(arg get(params i) context)
            if. ≠(len(pattern_ends) 0) internal_error("pattern_ends not empty")
            else, *.()
            for(bound_vars codegen_var_rc_incr)
            codegen_rc_decr(arg)
            bound_vars
    let. context′ C_Context(vars′ types)
    codegen_rc_decr(inner_captures_box)
    let. ret_val codegen_expr(body context′)
    for(vars′ codegen_var_rc_decr)
    codegen_ret(ret_val)
    set_insert_block(parent_block)
    *.(codegen_func_val(func outer_captures captures_type) captures_type)

set. codegen_expr λ. ∈.(expr T_Expr) ∈.(context C_Context):
    let. T_Expr(expr_data expr_type file_pos) expr
    case. expr_data
    .T_IntLiteral(n) codegen_const_int(n)
    .T_Ident(vi _)
        let. val case. c_lookup_var(vi context)
            .C_ConstVar(val) val
            .C_MutVar(var) codegen_load_mut_var(var)
            .C_Ctor(ctor _) ctor
            .C_Unused internal_error("Variable incorrectly marked as unused")
            .C_DCtor(_) internal_error("Variable incorrectly marked as unused")
        codegen_rc_incr(val)
        val
    .T_Tuple(exprs)
        codegen_tuple(list→vector(map(exprs λ.(e: codegen_expr(e context)))))
    .T_Apply(func args)
        codegen_apply(codegen_expr(func context) list→vector(map(args λ.(e: codegen_expr(e context)))))
    .T_If(cases else)
        let. branches map‡ cases λ. case:
            let. *.(cond body) case
            let. cond_val codegen_expr(cond context)
            let. cond_val_block get_insert_block()
            let. body_block begin_new_block()
            let. body_val codegen_expr(body context)
            let. body_end get_insert_block()
            let. next_block create_block()
            set_insert_block(cond_val_block)
            codegen_cond_br(cond_val body_block next_block)
            set_insert_block(next_block)
            *.(body_val body_end)
        let. else_val codegen_expr(else context)
        let. else_end get_insert_block()
        let. merge_block begin_new_block()
        let. phi codegen_phi(len(branches))
        for‡ branches λ. *.(body_val body_end):
            set_insert_block(body_end)
            codegen_br(merge_block)
            phi_add_incoming(phi body_val body_end)
        set_insert_block(else_end)
        codegen_br(merge_block)
        phi_add_incoming(phi else_val else_end)
        set_insert_block(merge_block)
        phi
    .T_And(subexprs)
        let. branches map‡ subexprs λ. cond:
            let. cond_val codegen_expr(cond context)
            let. cond_end get_insert_block()
            let. next_block begin_new_block()
            *.(cond_val cond_end next_block)
        let. true_block get_insert_block()
        let. true_val codegen_const_bool(1)
        let. false_block begin_new_block()
        let. false_val codegen_const_bool(0)
        for‡ branches λ. *.(cond_val cond_end next_block):
            set_insert_block(cond_end)
            codegen_cond_br(cond_val next_block false_block)
        let. merge_block begin_new_block()
        let. phi codegen_phi(2)
        set_insert_block(true_block)
        codegen_br(merge_block)
        set_insert_block(false_block)
        codegen_br(merge_block)
        phi_add_incoming(phi true_val true_block)
        phi_add_incoming(phi false_val false_block)
        set_insert_block(merge_block)
        phi
    .T_Or(subexprs)
        let. branches map‡ subexprs λ. cond:
            let. cond_val codegen_expr(cond context)
            let. cond_end get_insert_block()
            let. next_block begin_new_block()
            *.(cond_val cond_end next_block)
        let. false_block get_insert_block()
        let. false_val codegen_const_bool(0)
        let. true_block begin_new_block()
        let. true_val codegen_const_bool(1)
        for‡ branches λ. *.(cond_val cond_end next_block):
            set_insert_block(cond_end)
            codegen_cond_br(cond_val true_block next_block)
        let. merge_block begin_new_block()
        let. phi codegen_phi(2)
        set_insert_block(false_block)
        codegen_br(merge_block)
        set_insert_block(true_block)
        codegen_br(merge_block)
        phi_add_incoming(phi false_val false_block)
        phi_add_incoming(phi true_val true_block)
        set_insert_block(merge_block)
        phi
    .T_While(cond body)
        let. cond_block create_block()
        codegen_br(cond_block)
        set_insert_block(cond_block)
        let. cond_val codegen_expr(cond context)
        let. cond_val_block get_insert_block()
        let. body_block begin_new_block()
        codegen_rc_decr(codegen_expr(body context))
        codegen_br(cond_block)
        let. merge_block create_block()
        set_insert_block(cond_val_block)
        codegen_cond_br(cond_val body_block merge_block)
        set_insert_block(merge_block)
        codegen_tuple(list→vector(list.()))
    .T_Do(statements) codegen_statements(statements context)
    .T_Lambda(params body)
        let. C_Context(vars types) context
        let. is_captured free_vars(body len(vars))
        let. outer_captures list→vector(codegen_outer_captures(vars is_captured))
        let. *.(func _) codegen_function(params body context is_captured outer_captures)
        func
    .T_Case(expr cases)
        let. T_Expr(_ expr_type expr_file_pos) expr
        if. ¬(is_match_exhaustive(map(cases λ.(case:
            let. *.(pattern _) case
            list.(pattern)
        )) list.(expr_type) context))
        then, error(InexhaustivePatterns expr_file_pos)
        else, *.()
        let. C_Context(old_context_vars _) context
        let. old_context_len len(old_context_vars)
        let. matched_val codegen_expr(expr context)
        let. branches map‡ cases λ. case:
            let. *.(pattern body) case
            let. *.(bound_vars pattern_ends) codegen_pattern_test(matched_val pattern context)
            let. mut, context′ context
            for‡ bound_vars λ. var:
                codegen_var_rc_incr(var)
                set. context′ c_add_let_binding(context′ var)
            codegen_rc_decr(matched_val)
            let. body_val codegen_expr(body context′)
            let. C_Context(context_vars _) context
            for_ι‡ -(len(context_vars) old_context_len) λ. i:
                let. var get(context_vars +(i old_context_len))
                codegen_var_rc_decr(var)
            let. body_end get_insert_block()
            let. next_block create_block()
            for‡ pattern_ends λ. pattern_end:
                bind_pattern_end(pattern_end next_block)
            set_insert_block(next_block)
            *.(body_val body_end)
        codegen_unreachable()
        let. merge_block begin_new_block()
        let. phi codegen_phi(len(branches))
        for‡ branches λ. branch:
            let. *.(body_val body_end) branch
            set_insert_block(body_end)
            codegen_br(merge_block)
            phi_add_incoming(phi body_val body_end)
        set_insert_block(merge_block)
        phi
    .T_ListLiteral(exprs)
        codegen_list(list→vector(map(exprs λ.(e: codegen_expr(e context)))))

set. codegen_statements λ. ∈.(statements List(T_Statement)) ∈.(context C_Context):
    let. mut, context context
    let. C_Context(old_context_vars old_context_types) context
    let. old_context_len len(old_context_vars)
    let. mut, type_index_base len(old_context_types)
    for‡ statements λ. statement:
        case. statement
        .T_Statement(T_TypeStatement(num_type_params variants) _) set. type_index_base +(type_index_base 1)
        ._ *.()
    for‡ statements λ. statement:
        case. statement
        .T_Statement(T_TypeStatement(num_type_params variants) _)
            set. context c_add_type_binding‡ context
                map_ι(num_type_params λ.(i: +(type_index_base i)))
                variants
        ._ *.()
    let. mut, block_val None
    for‡ statements λ. statement:
        let. T_Statement(statement_data file_pos) statement
        case. statement_data
        .T_ExprStatement(expr)
            case. block_val
            .Some(val) codegen_rc_decr(val)
            .None *.()
            set. block_val Some(codegen_expr(expr context))
        .T_Let(pattern expr)
            let. T_Expr(_ expr_type _) expr
            if. ¬(is_match_exhaustive(list.(list.(pattern)) list.(expr_type) context))
            then, error(InexhaustivePatterns file_pos)
            else, *.()
            let. val codegen_expr(expr context)
            let. *.(bound_vars pattern_ends) codegen_pattern_test(val pattern context)
            if. ≠(len(pattern_ends) 0)
                internal_error("pattern_ends not empty")
            else, *.()
            for‡ bound_vars λ. var:
                codegen_var_rc_incr(var)
                set. context c_add_let_binding(context var)
            codegen_rc_decr(val)
        .T_Let∀(type_params expr)
            let. mut, context′ context
            for_ι(type_params λ.(i: set.(context′ c_add_type_binding(context′ list.() list.(list.())))))
            set. context c_add_let_binding(context C_ConstVar(codegen_expr(expr context)))
        .T_LetMut(expr)
            set. context c_add_let_binding(context C_MutVar(codegen_create_mut_var(codegen_expr(expr context))))
        .T_Fun(type_params defs)
            let. parent_block get_insert_block()
            let. C_Context(vars types) context
            let. captures_len +(len(vars) len(defs))
            let. mut, is_captured repeat(captures_len ⊥)
            for‡ defs λ. *.(_ body): set. is_captured case. zip(is_captured free_vars(body captures_len))
                .Some(abs) map(abs λ.(*.(a b): ∨.(a b)))
                .None internal_error("free_vars returned different lengths")
            let. ext_outer_captures codegen_outer_captures(vars is_captured)
            let. outer_captures list→vector(++(ext_outer_captures map(defs λ.(_: codegen_null()))))
            let. mut, context′ context
            for‡ defs λ. _: set. context′ c_add_let_binding(context′ C_ConstVar(0)) ※ value is irrelevant since it will be replaced inside function
            let. funs map‡ defs λ. *.(params body):
                codegen_function(params body context′ is_captured outer_captures)
            for‡ funs λ. *.(fun1 type1):
                for‡ ι*(funs) λ. *.(i *.(fun2 _)):
                    codegen_rc_incr(fun2)
                    codegen_set_capture(fun1 type1 +(len(ext_outer_captures) i) fun2)
            for‡ funs λ. *.(fun _): set. context c_add_let_binding(context C_ConstVar(fun))
        .T_TypeStatement(num_params variants)
            if. =(len(variants) 1)
                let. params get(variants 0)
                set. context c_add_let_binding(context C_Ctor(codegen_create_tagless_ctor(len(params)) None))
            else,
                for_ι‡ len(variants) λ. i:
                    let. params get(variants i)
                    set. context c_add_let_binding(context C_Ctor(codegen_create_tagged_ctor(len(params) i) Some(i)))
        .T_Extern(name type)
            case. type
            .T_Function(params ret)
                let. TypeName(int_type_index) int_type
                for‡ params λ. param:
                    case. param
                    .T_Named(i _)
                        if. ≠(i int_type_index)
                            error(InvalidExternType(name) file_pos)
                        else, *.()
                    ._
                        error(InvalidExternType(name) file_pos)
                let. ret_int case. ret
                    .T_Named(i _)
                        if. ≠(i int_type_index)
                            error(InvalidExternType(name) file_pos)
                        else, *.()
                        ⊤
                    .T_TupleType(list.()) ⊥
                    ._ error(InvalidExternType(name) file_pos)
                set. context c_add_let_binding‡ context
                    C_ConstVar(codegen_extern(utf8_encode(list→vector(name)) len(params) if.(ret_int 1 0)))
            ._
                error(InvalidExternType(name) file_pos)
        .T_Set(vi expr)
            case. c_lookup_var(vi context)
            .C_MutVar(var)
                let. val codegen_expr(expr context)
                codegen_rc_decr(codegen_load_mut_var(var))
                codegen_store_mut_var(var val)
            .C_Unused
                internal_error("Variable incorrectly marked as unused")
            ._ internal_error("Assignment to immutable variable")
    let. C_Context(context_vars _) context
    for_ι‡ -(len(context_vars) old_context_len) λ. i:
        let. var get(context_vars +(i old_context_len))
        codegen_var_rc_decr(var)
    case. block_val
    .Some(block_val) block_val
    .None codegen_tuple(list→vector(list.()))

set. codegen_pattern_test λ. ∈.(val Int) ∈.(pattern T_Pattern) ∈.(context C_Context):
    let. T_Pattern(pattern_data _ file_pos) pattern
    case. pattern_data
    .T_IntLiteralPattern(n) *.(list.() list.(codegen_int_pattern_test(val n)))
    .T_IdentPattern *.(list.(C_ConstVar(val)) list.())
    .T_WildcardPattern *.(list.() list.())
    .T_TuplePattern(patterns)
        let. tuple codegen_tuple_cast(val len(patterns))
        let. *.(bindings_ ends_) unzip‡ map_ι‡ len(patterns) λ. i:
            codegen_pattern_test(codegen_tuple_get(tuple i) get(patterns i) context)
        *.(concat(bindings_) concat(ends_))
    .T_VariantPattern(vi patterns _)
        let. tag case. c_lookup_var(vi context)
            .C_Ctor(_ tag) tag
            .C_DCtor(tag) tag
            ._ internal_error("Pattern is not a constructor, but was expected to be")
        case. tag
        .Some(tag)
            let. tagged codegen_tagged_cast(val len(patterns))
            let. tag_fail codegen_tag_check(tagged tag)
            let. *.(bindings_ ends_) unzip‡ map_ι‡ len(patterns) λ. i:
                codegen_pattern_test(codegen_tuple_get(tagged i) get(patterns i) context)
            *.(concat(bindings_) push(concat(ends_) tag_fail))
        .None
            let. tuple codegen_tuple_cast(val len(patterns))
            let. *.(bindings_ ends_) unzip‡ map_ι‡ len(patterns) λ. i:
                codegen_pattern_test(codegen_tuple_get(tuple i) get(patterns i) context)
            *.(concat(bindings_) concat(ends_))
    .T_ListPattern(patterns)
        let. list codegen_list_cast(val)
        let. len_fail codegen_len_check(list len(patterns))
        let. *.(bindings_ ends_) unzip‡ map_ι‡ len(patterns) λ. i:
            codegen_pattern_test(codegen_list_get(list i) get(patterns i) context)
        *.(concat(bindings_) push(concat(ends_) len_fail))
