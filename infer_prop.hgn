type. I_StatementData
    I_ExprStatement(I_Expr)
    I_Let(I_Pattern I_Expr)
    I_Let∀(List(TypeName) List(Int) I_Expr)
    I_LetMut(List(Int) I_Expr)
    I_TypeStatement(TypeName List(TypeName) List(*.(List(Int) List(TypeVar))))
    I_Extern(List(Int) TypeVar)
    I_Set(List(Int) I_Expr)

type. I_Statement I_Statement(I_StatementData FilePos)

type. I_ExprData
    I_IntLiteral(Int)
    I_Ident(List(Int) List(TypeVar))
    I_Tuple(List(I_Expr))
    I_Apply(I_Expr List(I_Expr))
    I_If(List(*.(I_Expr I_Expr)) I_Expr)
    I_While(I_Expr I_Expr)
    I_And(List(I_Expr))
    I_Or(List(I_Expr))
    I_Do(List(I_Statement))
    I_Lambda(List(I_Pattern) I_Expr)
    I_Case(I_Expr List(*.(I_Pattern I_Expr)))
    I_ListLiteral(List(I_Expr))

type. I_Expr I_Expr(I_ExprData TypeVar FilePos)

type. I_PatternData
    I_IntLiteralPattern(Int)
    I_IdentPattern(List(Int))
    I_WildcardPattern
    I_TuplePattern(List(I_Pattern))
    I_VariantPattern(List(Int) List(I_Pattern) List(TypeVar))
    I_ListPattern(List(I_Pattern))

type. I_Pattern I_Pattern(I_PatternData TypeVar FilePos)

type. TypeName TypeName(Int)
type. TypeVar TypeVar(Int)

let. =type_var λ. ∈.(tv1 TypeVar) ∈.(tv2 TypeVar):
    let. TypeVar(tvi1) tv1
    let. TypeVar(tvi2) tv2
    =(tvi1 tvi2)

let. =type_name λ. ∈.(tn1 TypeName) ∈.(tn2 TypeName):
    let. TypeName(tni1) tn1
    let. TypeName(tni2) tn2
    =(tni1 tni2)

type. I_Type
    I_Any
    I_Equal(TypeVar)
    I_Named(TypeName List(TypeVar))
    I_TupleType(List(TypeVar))
    I_Function(List(TypeVar) TypeVar)

let. i_expr_type λ. ∈.(expr I_Expr):
    let. I_Expr(_ type _) expr
    type

let. i_expr_file_pos λ. ∈.(expr I_Expr):
    let. I_Expr(_ _ file_pos) expr
    file_pos

let. i_pattern_type λ. ∈.(pattern I_Pattern):
    let. I_Pattern(_ type _) pattern
    type

let. i_pattern_file_pos λ. ∈.(pattern I_Pattern):
    let. I_Pattern(_ _ file_pos) pattern
    file_pos

let. mut, named_types list.()

let. new_type_name λ. ∈.(name Option(List(Int))) ∈.(params Int):
    set. named_types push(named_types *.(name params))
    TypeName(-(len(named_types) 1))

let. int_type new_type_name(Some("Int") 0)
let. bool_type new_type_name(Some("Bool") 0)
let. list_type new_type_name(Some("List") 1)

let. type_name_string λ. ∈.(tn TypeName):
    let. TypeName(tni) tn
    let. *.(name _) get(named_types tni)
    case. name
    .Some(name) name
    .None ++("?G" int→string(tni))

let. mut, type_variables list.()

let. mut, type_referenced_types′ λ. ∈.(tv TypeVar): list.()
set. type_referenced_types′ λ. ∈.(tv TypeVar):
    let. TypeVar(tvi) tv
    case. get(type_variables tvi)
    .I_Any list.(tv)
    .I_Equal(tv′) type_referenced_types′(tv′)
    .I_Named(_ args) concat(map(args type_referenced_types′))
    .I_TupleType(types) concat(map(types type_referenced_types′))
    .I_Function(params ret) concat(map(push(params ret) type_referenced_types′))

let. type_referenced_types λ. ∈.(tv TypeVar): dedup(type_referenced_types′(tv) =type_var)

let. mut, type_referenced_type_names′ λ. ∈.(tv TypeVar): list.()
set. type_referenced_type_names′ λ. ∈.(tv TypeVar):
    let. TypeVar(tvi) tv
    case. get(type_variables tvi)
    .I_Any list.()
    .I_Equal(tv′) type_referenced_type_names′(tv′)
    .I_Named(tn args) push(concat(map(args type_referenced_type_names′)) tn)
    .I_TupleType(types) concat(map(types type_referenced_type_names′))
    .I_Function(params ret) concat(map(push(params ret) type_referenced_type_names′))

let. type_referenced_type_names λ. ∈.(tv TypeVar): dedup(type_referenced_type_names′(tv) =type_name)

let. new_type_var_with_type λ. ∈.(type I_Type):
    set. type_variables push(type_variables type)
    TypeVar(-(len(type_variables) 1))

let. new_type_var λ.:
    new_type_var_with_type(I_Any)

let. assign_type_var λ. ∈.(tv TypeVar) ∈.(type I_Type) ∈.(file_pos FilePos):
    ※ FIXME awful hack to bypass type_referenced_types taking a TypeVar
    if. ∈(tv type_referenced_types(new_type_var_with_type(type)) =type_var)
        error(CyclicalType file_pos)
    else, *.()
    let. TypeVar(tvi) tv
    set. type_variables put(type_variables tvi type)

let. mut, i_type→partial_type λ. ∈.(t I_Type) ∈.(tvi Int): P_Var(0)
let. mut, type_var→partial_type λ. ∈.(tv TypeVar): P_Var(0)

set. i_type→partial_type λ. ∈.(t I_Type) ∈.(tvi Int):
    case. t
    .I_Any P_Var(tvi)
    .I_Equal(tv′) type_var→partial_type(tv′)
    .I_Named(tn args) P_Applied(type_name_string(tn) map(args type_var→partial_type))
    .I_TupleType(types) P_TupleType(map(types type_var→partial_type))
    .I_Function(params ret) P_Function(map(params type_var→partial_type) type_var→partial_type(ret))

set. type_var→partial_type λ. ∈.(tv TypeVar):
    let. TypeVar(tvi) tv
    i_type→partial_type(get(type_variables tvi) tvi)

let. mut, unify_type′ λ. ∈.(tv1 TypeVar) ∈.(tv2 TypeVar) ∈.(err Error) ∈.(file_pos FilePos): *.()
let. mut, set_type′ λ. ∈.(tv1 TypeVar) ∈.(t2 I_Type) ∈.(err Error) ∈.(file_pos FilePos): *.()

let. unify_type_value′ λ. ∈.(t1 I_Type) ∈.(t2 I_Type) ∈.(err Error) ∈.(file_pos FilePos):
    case. *.(t1 t2)
    .*.(I_Any _) *.()
    .*.(_ I_Any) *.()
    .*.(I_Equal(tv1) _) set_type′(tv1 t2 err file_pos)
    .*.(_ I_Equal(tv2)) set_type′(tv2 t1 err file_pos)
    .*.(I_Named(TypeName(n1) args1) I_Named(TypeName(n2) args2))
        if. =(n1 n2) case. for2(args1 args2 λ.(tv1 tv2: unify_type′(tv1 tv2 err file_pos)))
            .None error(err file_pos)
            .Some(*.()) *.()
        else,
            error(err file_pos)
    .*.(I_TupleType(types1) I_TupleType(types2))
        case. for2(types1 types2 λ.(tv1 tv2: unify_type′(tv1 tv2 err file_pos)))
        .None error(err file_pos)
        .Some(*.()) *.()
    .*.(I_Function(params1 ret1) I_Function(params2 ret2))
        case. for2(params1 params2 λ.(tv1 tv2: unify_type′(tv1 tv2 err file_pos)))
        .None error(err file_pos)
        .Some(*.()) *.()
        unify_type′(ret1 ret2 err file_pos)
    ._
        error(err file_pos)

set. unify_type′ λ. ∈.(tv1 TypeVar) ∈.(tv2 TypeVar) ∈.(err Error) ∈.(file_pos FilePos):
    if. =type_var(tv1 tv2) *.()
    else,
        let. TypeVar(tvi1) tv1
        let. TypeVar(tvi2) tv2
        let. t1 get(type_variables tvi1)
        let. t2 get(type_variables tvi2)
        case. *.(t1 t2)
        .*.(I_Equal(tv1′) _) unify_type′(tv1′ tv2 err file_pos)
        .*.(_ I_Equal(tv2′)) unify_type′(tv1 tv2′ err file_pos)
        .*.(I_Any _) assign_type_var(tv1 I_Equal(tv2) file_pos)
        .*.(_ I_Any) assign_type_var(tv2 I_Equal(tv1) file_pos)
        ._ unify_type_value′(t1 t2 err file_pos)

set. set_type′ λ. ∈.(tv1 TypeVar) ∈.(t2 I_Type) ∈.(err Error) ∈.(file_pos FilePos):
    let. TypeVar(tvi1) tv1
    let. t1 get(type_variables tvi1)
    case. *.(t1 t2)
    .*.(I_Equal(tv1′) _) set_type′(tv1′ t2 err file_pos)
    .*.(_ I_Equal(tv2′)) unify_type′(tv1 tv2′ err file_pos)
    .*.(I_Any _) assign_type_var(tv1 t2 file_pos)
    .*.(_ I_Any) *.()
    ._ unify_type_value′(t1 t2 err file_pos)

let. unify_type λ. ∈.(tv1 TypeVar) ∈.(tv2 TypeVar) ∈.(file_pos FilePos):
    unify_type′(tv1 tv2 ConflictingType(type_var→partial_type(tv1) type_var→partial_type(tv2)) file_pos)

let. set_type λ. ∈.(tv1 TypeVar) ∈.(t2 I_Type) ∈.(file_pos FilePos):
    set_type′(tv1 t2 ConflictingType(type_var→partial_type(tv1) i_type→partial_type(t2 -(0 1))) file_pos)

type. VarBinding VarBinding(List(Int) List(TypeName) TypeVar Bool)

type. I_Context I_Context‡
    List(VarBinding) ※ vars
    List(TypeName)   ※ types

let. bool_tv new_type_var_with_type(I_Named(bool_type list.()))
let. int_tv new_type_var_with_type(I_Named(int_type list.()))
let. unit_tv new_type_var_with_type(I_TupleType(list.()))
let. arith_tv new_type_var_with_type(I_Function(list.(int_tv int_tv) int_tv))
let. cmp_tv new_type_var_with_type(I_Function(list.(int_tv int_tv) bool_tv))
let. t_type new_type_name(None 0)
let. t_tv new_type_var_with_type(I_Named(t_type list.()))
let. list_tv new_type_var_with_type(I_Named(list_type list.(t_tv)))

let. builtin_types list.(int_type bool_type list_type)

let. empty_i_context I_Context‡
    list.
        VarBinding("⊤" list.() bool_tv ⊤)
        VarBinding("⊥" list.() bool_tv ⊤)
        VarBinding("+" list.() arith_tv ⊥)
        VarBinding("-" list.() arith_tv ⊥)
        VarBinding("*" list.() arith_tv ⊥)
        VarBinding("/" list.() arith_tv ⊥)
        VarBinding("%" list.() arith_tv ⊥)
        VarBinding("=" list.() cmp_tv ⊥)
        VarBinding("≠" list.() cmp_tv ⊥)
        VarBinding("<" list.() cmp_tv ⊥)
        VarBinding("≤" list.() cmp_tv ⊥)
        VarBinding(">" list.() cmp_tv ⊥)
        VarBinding("≥" list.() cmp_tv ⊥)
        VarBinding("empty" list.(t_type) list_tv ⊥)
        VarBinding("len" list.(t_type) new_type_var_with_type(I_Function(list.(list_tv) int_tv)) ⊥)
        VarBinding("get" list.(t_type) new_type_var_with_type(I_Function(list.(list_tv int_tv) t_tv)) ⊥)
        VarBinding("put" list.(t_type) new_type_var_with_type(I_Function(list.(list_tv int_tv t_tv) list_tv)) ⊥)
        VarBinding("push" list.(t_type) new_type_var_with_type(I_Function(list.(list_tv t_tv) list_tv)) ⊥)
        VarBinding("pop" list.(t_type) new_type_var_with_type(I_Function(list.(list_tv) list_tv)) ⊥)
        VarBinding("print_int" list.() new_type_var_with_type(I_Function(list.(int_tv) unit_tv)) ⊥)
        VarBinding("read_int" list.() new_type_var_with_type(I_Function(list.() int_tv)) ⊥)
        VarBinding("print_byte" list.() new_type_var_with_type(I_Function(list.(int_tv) unit_tv)) ⊥)
        VarBinding("read_byte" list.() new_type_var_with_type(I_Function(list.() int_tv)) ⊥)
        VarBinding("get_argc" list.() new_type_var_with_type(I_Function(list.() int_tv)) ⊥)
        VarBinding("get_argv_len" list.() new_type_var_with_type(I_Function(list.(int_tv) int_tv)) ⊥)
        VarBinding("get_argv_byte" list.() new_type_var_with_type(I_Function(list.(int_tv int_tv) int_tv)) ⊥)
        VarBinding("unreachable" list.(t_type) new_type_var_with_type(I_Function(list.() t_tv)) ⊥)
    builtin_types

let. i_add_let_binding λ. ∈.(context I_Context) ∈.(var VarBinding):
    let. I_Context(vars types) context
    I_Context(push(vars var) types)

let. i_add_type_binding λ. ∈.(context I_Context) ∈.(type TypeName):
    let. I_Context(vars types) context
    I_Context(vars push(types type))

let. ctor_type_if_exists λ. ∈.(name List(Int)) ∈.(context I_Context):
    let. mut, type None
    let. I_Context(vars _) context
    for‡ vars λ. var:
        let. VarBinding(name′ type_params monotype is_ctor) var
        if. ∧(=list(name name′ =) is_ctor)
            set. type Some(*.(type_params monotype))
        else, *.()
    type

let. variable_type λ. ∈.(name List(Int)) ∈.(context I_Context) ∈.(file_pos FilePos):
    let. mut, type None
    let. I_Context(vars _) context
    for‡ vars λ. var:
        let. VarBinding(name′ type_params monotype _) var
        if. =list(name name′ =)
            set. type Some(*.(type_params monotype))
        else, *.()
    case. type
    .Some(t) t
    .None
        error(UnboundVariable(name) file_pos)
        *.(list.() TypeVar(0))

let. type_from_name λ. ∈.(name List(Int)) ∈.(context I_Context) ∈.(file_pos FilePos):
    let. mut, type None
    let. I_Context(_ types) context
    for‡ types λ. tn:
        let. TypeName(tni) tn
        let. *.(name′ _) get(named_types tni)
        case. name′
        .Some(name′)
            if. =list(name′ name =)
                set. type Some(tn)
            else, *.()
        .None *.()
    case. type
    .Some(t) t
    .None
        error(UnboundType(name) file_pos)
        TypeName(0)

let. mut, substitute_type_names λ. ∈.(subs List(*.(TypeName TypeVar))) ∈.(tv TypeVar): tv
set. substitute_type_names λ. ∈.(subs List(*.(TypeName TypeVar))) ∈.(tv TypeVar):
    let. TypeVar(tvi) tv
    let. type case. get(type_variables tvi)
        .I_Any I_Equal(tv)
        .I_Equal(tv′) I_Equal(substitute_type_names(subs tv′))
        .I_Named(tn list.())
            let. TypeName(tni) tn
            let. mut, tvi′ None
            for‡ subs λ. sub:
                let. *.(TypeName(from) TypeVar(to)) sub
                if. =(from tni)
                    set. tvi′ Some(to)
                else, *.()
            case. tvi′
            .Some(tvi′) I_Equal(TypeVar(tvi′))
            .None I_Named(tn list.())
        .I_Named(tn args) I_Named(tn map(args λ.(t: substitute_type_names(subs t))))
        .I_TupleType(types) I_TupleType(map(types λ.(t: substitute_type_names(subs t))))
        .I_Function(params ret) I_Function(map(params λ.(t: substitute_type_names(subs t))) substitute_type_names(subs ret))
    new_type_var_with_type(type)

let. instantiate_params λ. ∈.(type_params List(TypeName)) ∈.(tv TypeVar):
    let. subs map(type_params λ.(tn: *.(tn new_type_var())))
    *.
        substitute_type_names(subs tv)
        map‡ subs λ. sub:
            let. *.(_ tv) sub
            tv

let. context_referenced_types λ. ∈.(context I_Context):
    let. I_Context(vars _) context
    dedup(concat(map(vars λ.(var:
        let. VarBinding(_ _ type _) var
        type_referenced_types(type)
    ))) =type_var)

let. dummy_i_expr I_Expr(I_IntLiteral(0) TypeVar(0) FilePos(" " 0 0))
let. dummy_i_pattern I_Pattern(I_IntLiteralPattern(0) TypeVar(0) FilePos(" " 0 0))

let. mut, u_statements→i_statements λ. ∈.(statements List(U_Statement)) ∈.(context I_Context) ∈.(this_type TypeVar) ∈.(file_pos FilePos): list.()
let. mut, u_expr→i_expr λ. ∈.(expr U_Expr) ∈.(context I_Context): dummy_i_expr
let. mut, u_patterns→i_patterns λ. ∈.(u_patterns List(U_Pattern)) ∈.(context I_Context): *.(list.() list.())
let. mut, u_pattern→i_pattern λ. ∈.(u_pattern U_Pattern) ∈.(context I_Context): *.(dummy_i_pattern list.())
let. mut, u_type→i_type λ. ∈.(u_type U_Type) ∈.(context I_Context): I_Any

set. u_expr→i_expr λ. ∈.(expr U_Expr) ∈.(context I_Context):
    let. this_type new_type_var()
    let. U_Expr(u_expr_data file_pos) expr
    let. i_expr_data case. u_expr_data
        .U_IntLiteral(n)
            set_type(this_type I_Named(int_type list.()) file_pos)
            I_IntLiteral(n)
        .U_Ident(name)
            let. *.(type_params type) variable_type(name context file_pos)
            let. *.(var_type type_args) instantiate_params(type_params type)
            unify_type(this_type var_type file_pos)
            I_Ident(name type_args)
        .U_Tuple(u_exprs)
            let. i_exprs map(u_exprs λ.(e: u_expr→i_expr(e context)))
            set_type(this_type I_TupleType(map(i_exprs i_expr_type)) file_pos)
            I_Tuple(i_exprs)
        .U_Apply(u_func u_args)
            let. i_func u_expr→i_expr(u_func context)
            let. i_args map(u_args λ.(e: u_expr→i_expr(e context)))
            set_type(i_expr_type(i_func) I_Function(map(i_args i_expr_type) this_type) i_expr_file_pos(i_func))
            I_Apply(i_func i_args)
        .U_Typed(u_expr u_type)
            let. I_Expr(i_expr_data i_expr_type i_expr_file_pos) u_expr→i_expr(u_expr context)
            unify_type(this_type i_expr_type file_pos)
            set_type(i_expr_type u_type→i_type(u_type context) i_expr_file_pos)
            i_expr_data
        .U_If(u_cases u_else)
            let. i_cases map‡ u_cases λ. u_case:
                let. *.(u_cond u_body) u_case
                let. i_cond u_expr→i_expr(u_cond context)
                let. i_body u_expr→i_expr(u_body context)
                set_type(i_expr_type(i_cond) I_Named(bool_type list.()) i_expr_file_pos(i_cond))
                unify_type(this_type i_expr_type(i_body) file_pos)
                *.(i_cond i_body)
            let. i_else u_expr→i_expr(u_else context)
            unify_type(this_type i_expr_type(i_else) file_pos)
            I_If(i_cases i_else)
        .U_While(u_cond u_body)
            let. i_cond u_expr→i_expr(u_cond context)
            let. i_body u_expr→i_expr(u_body context)
            set_type(i_expr_type(i_cond) I_Named(bool_type list.()) i_expr_file_pos(i_cond))
            set_type(i_expr_type(i_body) I_TupleType(list.()) i_expr_file_pos(i_cond))
            set_type(this_type I_TupleType(list.()) file_pos)
            I_While(i_cond i_body)
        .U_Do(u_statements)
            I_Do(u_statements→i_statements(u_statements context this_type file_pos))
        .U_Lambda(u_params u_body)
            let. *.(i_params bindings) u_patterns→i_patterns(u_params context)
            let. mut, context′ context
            for‡ bindings λ. binding:
                set. context′ i_add_let_binding(context′ binding)
            let. i_body u_expr→i_expr(u_body context′)
            set_type(this_type I_Function(map(i_params i_pattern_type) i_expr_type(i_body)) file_pos)
            I_Lambda(i_params i_body)
        .U_Case(u_expr u_cases)
            let. i_expr u_expr→i_expr(u_expr context)
            let. i_cases map‡ u_cases λ. u_case:
                let. *.(u_pattern u_body) u_case
                let. *.(i_pattern bindings) u_pattern→i_pattern(u_pattern context)
                let. mut, context′ context
                for‡ bindings λ. binding:
                    set. context′ i_add_let_binding(context′ binding)
                let. i_body u_expr→i_expr(u_body context′)
                unify_type(i_pattern_type(i_pattern) i_expr_type(i_expr) i_pattern_file_pos(i_pattern))
                unify_type(this_type i_expr_type(i_body) file_pos)
                *.(i_pattern i_body)
            I_Case(i_expr i_cases)
        .U_And(u_exprs)
            let. i_exprs map(u_exprs λ.(u_expr: u_expr→i_expr(u_expr context)))
            for‡ i_exprs λ. i_expr: set_type(i_expr_type(i_expr) I_Named(bool_type list.()) i_expr_file_pos(i_expr))
            set_type(this_type I_Named(bool_type list.()) file_pos)
            I_And(i_exprs)
        .U_Or(u_exprs)
            let. i_exprs map(u_exprs λ.(u_expr: u_expr→i_expr(u_expr context)))
            for‡ i_exprs λ. i_expr: set_type(i_expr_type(i_expr) I_Named(bool_type list.()) i_expr_file_pos(i_expr))
            set_type(this_type I_Named(bool_type list.()) file_pos)
            I_Or(i_exprs)
        .U_ListLiteral(u_exprs)
            let. i_exprs map(u_exprs λ.(u_expr: u_expr→i_expr(u_expr context)))
            let. elem_type new_type_var()
            set_type(this_type I_Named(list_type list.(elem_type)) file_pos)
            for‡ i_exprs λ. i_expr: unify_type(i_expr_type(i_expr) elem_type i_expr_file_pos(i_expr))
            I_ListLiteral(i_exprs)
        .U_StringLiteral(s)
            let. elem_type new_type_var_with_type(I_Named(int_type list.()))
            set_type(this_type I_Named(list_type list.(elem_type)) file_pos)
            I_ListLiteral(map(s λ.(c: I_Expr(I_IntLiteral(c) elem_type file_pos))))
    I_Expr(i_expr_data this_type file_pos)

set. u_statements→i_statements λ. ∈.(statements List(U_Statement)) ∈.(context I_Context) ∈.(this_type TypeVar) ∈.(file_pos FilePos):
    let. mut, context context
    let. type_names concat‡ map‡ statements λ. statement:
        case. statement
        .U_Statement(U_TypeStatement(name type_params _) _)
            let. tn new_type_name(Some(name) len(type_params))
            set. context i_add_type_binding(context tn)
            list.(tn)
        ._ list.()
    let. mut, next_type_name 0
    let. mut, last_expr_type I_TupleType(list.())
    let. i_statements map‡ statements λ. statement:
        let. U_Statement(u_statement_data file_pos) statement
        let. i_statement_data case.(u_statement_data
        .U_ExprStatement(u_expr)
            let. i_expr u_expr→i_expr(u_expr context)
            set. last_expr_type I_Equal(i_expr_type(i_expr))
            I_ExprStatement(i_expr)
        .U_Let(u_pattern u_expr)
            let. i_expr u_expr→i_expr(u_expr context)
            case. u_pattern
            .U_Pattern(U_IdentPattern(name) _)
                let. type_params \(type_referenced_types(i_expr_type(i_expr)) context_referenced_types(context) =type_var)
                let. type_names map‡ type_params λ. tv:
                    let. tn new_type_name(None 0)
                    set_type(tv I_Named(tn list.()) file_pos)
                    tn
                set. context i_add_let_binding(context VarBinding(name type_names i_expr_type(i_expr) ⊥))
                I_Let∀(type_names name i_expr)
            ._
                let. *.(i_pattern bindings) u_pattern→i_pattern(u_pattern context)
                unify_type(i_expr_type(i_expr) i_pattern_type(i_pattern) i_expr_file_pos(i_expr))
                for‡ bindings λ. binding:
                    set. context i_add_let_binding(context binding)
                I_Let(i_pattern i_expr)
        .U_Let∀(type_param_names name u_expr)
            let. mut, context′ context
            let. type_params map‡ type_param_names λ. name:
                let. tn new_type_name(Some(name) 0)
                set. context′ i_add_type_binding(context′ tn)
                tn
            let. i_expr u_expr→i_expr(u_expr context′)
            let. unused_type_params \(type_params type_referenced_type_names(i_expr_type(i_expr)) =type_name)
            if. ≠(len(unused_type_params) 0)
                let. TypeName(tni) get(unused_type_params 0)
                let. *.(unused_name _) get(named_types tni)
                let. unused_name case. unused_name
                    .Some(name) name
                    .None
                        unreachable("unused_name is None")
                        list.()
                error(UnusedTypeParam(unused_name) file_pos)
            else, *.()
            set. context i_add_let_binding(context VarBinding(name type_params i_expr_type(i_expr) ⊥))
            I_Let∀(type_params name i_expr)
        .U_LetMut(name u_expr)
            let. i_expr u_expr→i_expr(u_expr context)
            set. context i_add_let_binding(context VarBinding(name list.() i_expr_type(i_expr) ⊥))
            I_LetMut(name i_expr)
        .U_TypeStatement(name type_param_names u_variants)
            let. mut, context′ context
            let. type_params map‡ type_param_names λ. name:
                let. tn new_type_name(Some(name) 0)
                set. context′ i_add_type_binding(context tn)
                tn
            let. type_name get(type_names next_type_name)
            set. next_type_name +(next_type_name 1)
            let. type I_Named(type_name map(type_params λ.(tn: new_type_var_with_type(I_Named(tn list.())))))
            let. type_tv new_type_var_with_type(type)
            let. i_variants map‡ u_variants λ. variant:
                let. *.(variant_name u_params) variant
                let. i_params map(u_params λ.(t: new_type_var_with_type(u_type→i_type(t context′))))
                let. ctor_type if.(>(len(i_params) 0) new_type_var_with_type(I_Function(i_params type_tv)) type_tv)
                set. context i_add_let_binding(context VarBinding(variant_name type_params ctor_type ⊤))
                *.(variant_name i_params)
            I_TypeStatement(type_name type_params i_variants)
        .U_Extern(name u_type)
            let. type new_type_var_with_type(u_type→i_type(u_type context))
            set. context i_add_let_binding(context VarBinding(name list.() type ⊥))
            I_Extern(name type)
        .U_Set(name u_expr)
            let. *.(type_params var_type) variable_type(name context file_pos)
            if. ≠(len(type_params) 0)
                error(AssignToConst(name) file_pos)
            else, *.()
            let. i_expr u_expr→i_expr(u_expr context)
            unify_type(i_expr_type(i_expr) var_type i_expr_file_pos(i_expr))
            I_Set(name i_expr)
        )
        I_Statement(i_statement_data file_pos)
    set_type(this_type last_expr_type file_pos)
    i_statements

set. u_patterns→i_patterns λ. ∈.(u_patterns List(U_Pattern)) ∈.(context I_Context):
    let. *.(i_patterns bindings_) unzip(map(u_patterns λ.(p: u_pattern→i_pattern(p context))))
    let. bindings concat(bindings_)
    *.(i_patterns bindings)

set. u_pattern→i_pattern λ. ∈.(u_pattern U_Pattern) ∈.(context I_Context):
    let. this_type new_type_var()
    let. U_Pattern(u_pattern_data file_pos) u_pattern
    let. *.(i_pattern_data bindings) case. u_pattern_data
        .U_IntLiteralPattern(n)
            set_type(this_type I_Named(int_type list.()) file_pos)
            *.(I_IntLiteralPattern(n) list.())
        .U_IdentPattern(name)
            case. ctor_type_if_exists(name context)
            .Some(*.(type_params type))
                let. *.(ctor_type type_args) instantiate_params(type_params type)
                unify_type(ctor_type this_type file_pos)
                *.(I_VariantPattern(name list.() type_args) list.())
            .None
                *.(I_IdentPattern(name) list.(VarBinding(name list.() this_type ⊥)))
        .U_WildcardPattern
            *.(I_WildcardPattern list.())
        .U_TuplePattern(u_patterns)
            let. *.(i_patterns bindings) u_patterns→i_patterns(u_patterns context)
            set_type(this_type I_TupleType(map(i_patterns i_pattern_type)) file_pos)
            *.(I_TuplePattern(i_patterns) bindings)
        .U_VariantPattern(ctor u_args)
            let. *.(i_args bindings) u_patterns→i_patterns(u_args context)
            let. *.(type_params type) variable_type(ctor context file_pos)
            let. *.(ctor_type type_args) instantiate_params(type_params type)
            set_type(ctor_type I_Function(map(i_args i_pattern_type) this_type) file_pos)
            *.(I_VariantPattern(ctor i_args type_args) bindings)
        .U_ListPattern(u_patterns)
            let. *.(i_patterns bindings) u_patterns→i_patterns(u_patterns context)
            let. elem_type new_type_var()
            set_type(this_type I_Named(list_type list.(elem_type)) file_pos)
            for‡ i_patterns λ. i_pattern: unify_type(i_pattern_type(i_pattern) elem_type file_pos)
            *.(I_ListPattern(i_patterns) bindings)
        .U_TypedPattern(u_pattern u_type)
            let. *.(i_pattern bindings) u_pattern→i_pattern(u_pattern context)
            unify_type(this_type i_pattern_type(i_pattern) file_pos)
            set_type(this_type u_type→i_type(u_type context) file_pos)
            let. I_Pattern(i_pattern_data _ _) i_pattern
            *.(i_pattern_data bindings)
    *.(I_Pattern(i_pattern_data this_type file_pos) bindings)

set. u_type→i_type λ. ∈.(u_type U_Type) ∈.(context I_Context):
    let. U_Type(type_data file_pos) u_type
    case. type_data
    .U_Named(name u_args)
        let. tn type_from_name(name context file_pos)
        let. TypeName(tni) tn
        let. *.(_ arity) get(named_types tni)
        if. ≠(arity len(u_args))
            error(IncorrectTypeArity(len(u_args) arity) file_pos)
        else, *.()
        let. i_args map(u_args λ.(t: new_type_var_with_type(u_type→i_type(t context))))
        I_Named(tn i_args)
    .U_TupleType(u_types)
        let. i_types map(u_types λ.(t: new_type_var_with_type(u_type→i_type(t context))))
        I_TupleType(i_types)
    .U_Function(u_params u_ret)
        let. i_params map(u_params λ.(t: new_type_var_with_type(u_type→i_type(t context))))
        let. i_ret new_type_var_with_type(u_type→i_type(u_ret context))
        I_Function(i_params i_ret)
